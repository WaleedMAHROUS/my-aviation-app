<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aviation Wildlife Risk Intelligence Platform | By Waleed Mahrous</title>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<style>
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');
:root {
--primary-blue: #1a365d; --secondary-blue: #2d3748; --accent-red: #e53e3e;
--accent-orange: #dd6b20; --accent-green: #38a169; --light-bg: #f7fafc;
--card-bg: rgba(255, 255, 255, 0.6);
--input-bg: rgba(255, 255, 255, 0.7);
--text-dark: #2d3748; --text-light: #5a687c;
--border-color: rgba(226, 232, 240, 0.7);
--shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
--shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
--radius: 12px; --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
--risk-intolerable: #e53e3e;
--risk-tolerable: #dd6b20;
--risk-acceptable: #38a169;
--risk-intolerable-bg: rgba(229, 62, 62, 0.6);
--risk-tolerable-bg: rgba(246, 224, 94, 0.6);
--risk-acceptable-bg: rgba(104, 211, 145, 0.6);
}
body {
font-family: 'Poppins', sans-serif;
background-color: #f0f4f8;
background-image: radial-gradient(at 0% 0%, hsla(216, 80%, 95%, 1) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(280, 80%, 95%, 1) 0px, transparent 50%);
color: var(--text-dark);
margin: 0;
padding: 2rem;
}
.container {
background-color: rgba(255, 255, 255, 0.3);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border-radius: 16px;
border: 1px solid rgba(255, 255, 255, 0.4);
box-shadow: var(--shadow-lg);
width: 100%;
max-width: 1600px;
padding: 2.5rem;
margin: 0 auto;
box-sizing: border-box;
}
header { text-align: center; margin-bottom: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 1.5rem; }
header h1 { color: var(--primary-blue); margin: 0; font-weight: 700; font-size: 2rem; }
.tagline { color: var(--text-light); font-size: 1rem; max-width: 700px; margin: 0.5rem auto 0; }
.welcome-section { text-align: center; padding: 2rem 1rem; margin-bottom: 2rem; background-color: var(--input-bg); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: var(--radius); border: 1px solid rgba(255, 255, 255, 0.3); }
.welcome-section h2 { color: var(--primary-blue); font-weight: 600; margin-top: 0; }
.welcome-section p { color: var(--text-dark); max-width: 800px; margin: 1rem auto; line-height: 1.7; }
.welcome-section .attribution { margin-top: 1.5rem; font-size: 0.9rem; color: var(--text-light); }
.welcome-section .attribution a { color: var(--primary-blue); text-decoration: none; font-weight: 500; }
.input-section { display: flex; justify-content: center; align-items: flex-end; gap: 1.5rem; margin-bottom: 2rem; flex-wrap: wrap; padding: 1.5rem; background-color: var(--input-bg); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: var(--radius); border: 1px solid rgba(255, 255, 255, 0.3); }
.input-field { flex: 1; min-width: 200px; position: relative; }
.input-field label { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; font-weight: 600; font-size: 0.9rem; }
.input-field input, .input-field select, .input-field textarea { width: 100%; padding: 0.75rem 1rem; border: 1px solid var(--border-color); border-radius: var(--radius); font-size: 1rem; background-color: rgba(255,255,255,0.8); box-sizing: border-box; }
.tooltip-icon { cursor: help; color: var(--text-light); font-weight: bold; border: 1px solid var(--text-light); border-radius: 50%; width: 20px; height: 20px; display: inline-flex; justify-content: center; align-items: center; font-size: 0.8rem; }
.tooltip-text { visibility: hidden; width: 320px; background-color: var(--secondary-blue); color: #fff; text-align: left; border-radius: var(--radius); padding: 1rem; position: absolute; z-index: 100; bottom: 125%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.3s; box-shadow: var(--shadow-lg); font-size: 0.9rem; line-height: 1.5; }
.tooltip-text::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: var(--secondary-blue) transparent transparent transparent; }
.has-tooltip { position: relative; display: inline-block; }
.has-tooltip:hover .tooltip-text { visibility: visible; opacity: 1; }
.tooltip-text h4 { margin-top: 0; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 0.5rem; margin-bottom: 0.5rem; font-size: 1rem; color: #fff;}
.btn { background: var(--primary-blue); color: white; border: none; border-radius: var(--radius); padding: 0.8rem 1.5rem; font-size: 1rem; font-weight: 600; cursor: pointer; transition: var(--transition); box-shadow: var(--shadow); }
.btn-danger { background-color: var(--accent-red); }
.btn-danger:hover { background-color: #c53030; }
.btn:hover { background: var(--secondary-blue); transform: translateY(-2px); }
.btn-secondary { background-color: var(--accent-green); }
.btn-secondary:hover { background-color: #2f855a; }
.btn-delete {
    padding: 0.2rem 0.6rem;
    font-size: 0.8rem;
    line-height: 1;
}
#status-container { text-align: center; padding: 2rem; }
.loader { width: 50px; height: 50px; border: 5px solid #e2e8f0; border-top-color: var(--primary-blue); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem; }
@keyframes spin { to { transform: rotate(360deg); } }
.status-message { padding: 1rem; border-radius: var(--radius); }
.status-message.error { color: var(--accent-red); background-color: #fed7d7; }
.status-message.demo { color: var(--accent-orange); background-color: #feebc8;}
.tabs { display: flex; border-bottom: 2px solid var(--border-color); margin-bottom: 1.5rem; flex-wrap: wrap; }
.tab-link { padding: 0.75rem 1.5rem; cursor: pointer; font-weight: 600; color: var(--text-light); border-bottom: 3px solid transparent; margin-bottom: -2px; }
.tab-link.active { color: var(--primary-blue); border-bottom-color: var(--primary-blue); }
.tab-content { display: none; }
.tab-content.active { display: block; }
.tab-airport-header {
    padding: 1rem 1.5rem;
    background-color: var(--input-bg);
    border-radius: var(--radius);
    margin-bottom: 1.5rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--primary-blue);
    text-align: center;
}
.dashboard-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem; }
.stat-card { background: var(--card-bg); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 1.5rem; border-radius: var(--radius); border: 1px solid rgba(255, 255, 255, 0.3); box-shadow: var(--shadow); border-left: 5px solid; position: relative; }
.stat-card.intolerable { border-color: var(--accent-red); }
.stat-card.tolerable { border-color: var(--accent-orange); }
.stat-card.acceptable { border-color: var(--accent-green); }
.stat-card.neutral { border-color: var(--primary-blue); }
.stat-value { font-size: 2.25rem; font-weight: 700; }
.stat-label { color: var(--text-light); font-size: 0.9rem; display: flex; align-items: center; gap: 0.5rem; }
.results-layout { display: grid; grid-template-columns: repeat(12, 1fr); gap: 1.5rem; margin-top: 1.5rem;}
.result-card { background: var(--card-bg); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 1.5rem; border-radius: var(--radius); border: 1px solid rgba(255, 255, 255, 0.3); box-shadow: var(--shadow); }
.result-card h3, .result-card h4 { margin-top: 0; margin-bottom: 1rem; color: var(--secondary-blue); font-size: 1.25rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.75rem; }
.result-card-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
.header-buttons { display: flex; gap: 1rem; flex-wrap: wrap; }
#map-container, #matrix-container, #methodology-container { grid-column: span 12; }
#map { width: 100%; height: 500px; border-radius: var(--radius); margin-bottom: 1rem; }
#map-caption, #trends-caption { font-size: 0.9rem; color: var(--text-light); line-height: 1.6; border-left: 3px solid var(--primary-blue); padding-left: 1rem; margin-top: 1rem; }
.download-controls { display: flex; justify-content: flex-end; gap: 1rem; margin-top: 1rem; }
.log-table { width: 100%; border-collapse: collapse; margin-top: 1rem;}
.log-table th, .log-table td { text-align: left; padding: 0.75rem; border-bottom: 1px solid var(--border-color); }
.log-table th { background-color: transparent; }
#ibis-form-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1.5rem; }
.form-section { grid-column: 1 / -1; margin-top: 1rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem; }
.form-section h4 { margin-top: 0; color: var(--primary-blue); }
.checkbox-group label { display: flex; align-items: center; gap: 0.5rem; }
.risk-matrix-wrapper { display: flex; }
.risk-matrix-y-axis { display: flex; flex-direction: column; justify-content: space-around; font-weight: bold; text-align: right; padding-right: 1rem; }
.risk-matrix-y-axis div { flex: 1; display: flex; align-items: center; justify-content: flex-end; }
.risk-matrix { display: grid; grid-template-columns: repeat(5, 1fr); grid-template-rows: auto repeat(5, 1fr); gap: 0.5rem; text-align: center; flex-grow: 1; }
.matrix-header { font-weight: bold; grid-column: span 1; padding-bottom: 0.5rem; border-bottom: 2px solid var(--border-color); margin-bottom: 0.5rem;}
.matrix-cell { border-radius: var(--radius); padding: 0.5rem; min-height: 80px; overflow-y: auto; max-height: 120px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.2); }
.matrix-cell-content { display: flex; flex-wrap: wrap; gap: 0.25rem; justify-content: center; align-items: flex-start; }
.matrix-cell-item { background: rgba(0,0,0,0.2); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; cursor: default; }
.matrix-cell.tolerable .matrix-cell-item { background: rgba(0,0,0,0.1); color: #2d3748; }
.matrix-cell.acceptable .matrix-cell-item { background: rgba(0,0,0,0.1); color: #2d3748; }
.matrix-cell.intolerable { background-color: var(--risk-intolerable-bg); }
.matrix-cell.tolerable { background-color: var(--risk-tolerable-bg); color: #333; }
.matrix-cell.acceptable { background-color: var(--risk-acceptable-bg); }
.chart-wrapper { position: relative; height: 400px; width: 100%; }
.ibis-charts-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 1.5rem; }
.species-tag-container .content { display: flex; flex-wrap: wrap; gap: 0.5rem; }
.species-tag { padding: 0.25rem 0.75rem; border-radius: 15px; font-weight: 500; font-size: 0.9rem; }
.intolerable-tag { background-color: #fed7d7; color: #c53030; }
.tolerable-tag { background-color: #feebc8; color: #9c4221; }
.acceptable-tag { background-color: #c6f6d5; color: #2f855a; }
#methodology-container ul, #about ul { list-style-type: none; padding-left: 0; }
#methodology-container li, #about li { margin-bottom: 1rem; padding-left: 2rem; position: relative; }
#methodology-container li::before, #about li::before { content: '✔'; color: var(--primary-blue); position: absolute; left: 0; font-size: 1.2rem; }
#about a { color: var(--primary-blue); font-weight: 500; }
.species-gallery a { text-decoration: none; color: inherit; }
.species-gallery { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 0.5rem; }
.species-image-card { background: rgba(255,255,255,0.5); border-radius: var(--radius); overflow: hidden; box-shadow: var(--shadow); width: 150px; text-align: center; transition: var(--transition); }
.species-image-card:hover { transform: translateY(-3px); box-shadow: var(--shadow-lg); }
.species-image-card img { display: block; width: 100%; height: 100px; object-fit: cover; }
.species-image-caption { padding: 0.5rem; font-size: 0.8rem; font-weight: 500; }
.process-flow { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 1rem; margin-top: 1.5rem; }
.process-step { flex: 1; min-width: 200px; padding: 1rem; border-radius: var(--radius); text-align: center; border-top: 4px solid; }
.process-step h4 { margin: 0 0 0.5rem 0; font-size: 1rem; color: var(--text-dark); }
.process-step p { font-size: 0.85rem; line-height: 1.5; color: var(--text-light); margin: 0; }
.process-arrow { font-size: 2rem; color: var(--border-color); }
.step-intolerable { border-color: var(--risk-intolerable); background-color: rgba(229, 62, 62, 0.05); }
.step-tolerable { border-color: var(--risk-tolerable); background-color: rgba(221, 107, 32, 0.05); }
.step-acceptable { border-color: var(--risk-acceptable); background-color: rgba(56, 161, 105, 0.05); }
.step-neutral { border-color: var(--primary-blue); background-color: rgba(26, 54, 93, 0.05); }
.framework-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; }
.framework-card { padding: 1rem; border-left: 3px solid; }
.framework-card h4 { margin-top: 0; }
.framework-card p, .framework-card ul { color: var(--text-light); font-size: 0.9rem; }
.framework-card ul { padding-left: 20px; }
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: none;
    /* justify-content: center; <-- REMOVED */
    /* align-items: center; <-- REMOVED */
    z-index: 10000;
    /* Increased from 1000 to ensure it's on top */
    padding: 1rem;
    box-sizing: border-box;
    overflow-y: auto; /* Allow scrolling within modal if content is too tall */
}
.modal-content {
    position: absolute; /* <-- ADD THIS LINE */
    background: white;
    padding: 2rem;
    border-radius: var(--radius);
    box-shadow: var(--shadow-lg);
    text-align: center;
    max-width: 400px; /* Adjust max-width as needed */
    width: 90%; /* Use percentage for responsiveness */
    max-height: 90vh; /* Added: Limit height to 90% of viewport height */
    overflow-y: auto; /* Added: Allow vertical scrolling if content overflows */
    box-sizing: border-box; /* Added for consistency */
}
.modal-buttons { margin-top: 1.5rem; display: flex; justify-content: center; gap: 1rem; }
.leaflet-control-attribution, .leaflet-control-zoom { display: none; }
.info.legend i { width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.7; border: 1px solid rgba(0,0,0,0.2); }
.toggle-container { display: flex; align-items: center; gap: 0.75rem; font-size: 0.9rem; font-weight: 500; }
.switch { position: relative; display: inline-block; width: 44px; height: 24px; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
.slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
input:checked + .slider { background-color: var(--primary-blue); }
input:checked + .slider:before { transform: translateX(20px); }
.airport-toggle-section { margin-bottom: 1.5rem; padding: 1rem; background-color: var(--input-bg); border-radius: var(--radius); border: 1px solid rgba(255, 255, 255, 0.3); }
.airport-toggle-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; margin-top: 1rem; }
.airport-toggle-item { display: flex; align-items: center; gap: 0.5rem; }
.airport-toggle-item label { font-weight: 500; cursor: pointer; }
.airport-toggle-item input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }/* Styles for Manual Override Feature */
.override-controls { 
    display: flex; 
    align-items: center; 
    gap: 1rem; 
    margin-bottom: 1rem; 
    justify-content: flex-end;
}
.override-mode-active .matrix-cell-item {
    cursor: pointer !important;
    box-shadow: 0 0 0 2px var(--primary-blue);
}
.matrix-cell-item.manually-adjusted {
    position: relative;
    border: 1px dashed var(--primary-blue);
}
.matrix-cell-item.manually-adjusted::after {
    content: '★';
    position: absolute;
    top: -8px;
    right: -5px;
    color: var(--primary-blue);
    font-size: 1rem;
    background-color: white;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    line-height: 16px;
    text-align: center;
}
/* STYLES FOR NEW DASHBOARD CARDS */
.local-data-dashboard {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 1.5rem;
    margin-bottom: 1.5rem;
    padding: 1.5rem;
    background-color: var(--input-bg);
    border-radius: var(--radius);
    border: 1px solid rgba(255, 255, 255, 0.3);
}
.airport-list {
    grid-column: 1 / -1;
    font-size: 0.9rem;
    color: var(--text-dark);
}
.airport-list .content {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
}
.airport-list .airport-tag {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    border-radius: 15px;
    font-weight: 500;
    background-color: #e2e8f0;
    color: var(--secondary-blue);
    transition: var(--transition);
}
.airport-list .airport-tag-upcoming {
    background-color: var(--accent-orange);
    color: white;
    box-shadow: 0 0 8px rgba(221, 107, 32, 0.7);
    animation: pulse 2s infinite;
}
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}
/* END OF NEW STYLES */
@media (max-width: 900px) { body { padding: 1rem; } .container { padding: 1.5rem; } header h1 { font-size: 1.75rem; } .input-section { flex-direction: column; align-items: stretch; gap: 1rem; } .risk-matrix-wrapper { overflow-x: auto; padding-bottom: 1rem; } .risk-matrix { min-width: 700px; } .process-arrow { display: none; } .process-step { margin-bottom: 1rem; } }
@media (max-width: 600px) { body { padding: 0.5rem; } .container { padding: 1rem; } header h1 { font-size: 1.4rem; } .tagline { font-size: 0.9rem; } .welcome-section p { font-size: 0.9rem; } .tabs { justify-content: flex-start; } .tab-link { padding: 0.5rem 1rem; font-size: 0.9rem; } .result-card-header { flex-direction: column; align-items: flex-start; } .ibis-charts-grid { grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); } .stat-card { padding: 1rem; } .stat-value { font-size: 1.75rem; } .stat-label { font-size: 0.8rem; } .result-card { padding: 1rem; } .log-table-container { overflow-x: auto; } .log-table { display: block; } .modal-content { padding: 1.5rem; } }

/* --- NEW STYLES FOR NEXT STEPS --- */
.next-steps-container {
    margin-top: 1.5rem;
    padding-top: 1.5rem;
    border-top: 1px solid var(--border-color);
}
.next-steps-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5rem;
    margin-top: 1rem;
}
.next-step-card {
    background-color: rgba(255, 255, 255, 0.4);
    border-radius: var(--radius);
    padding: 1.5rem;
    border: 1px solid var(--border-color);
    box-shadow: var(--shadow);
    transition: var(--transition);
}
.next-step-card h4 {
    margin-top: 0;
    margin-bottom: 0.5rem;
    color: var(--secondary-blue);
    font-size: 1.1rem;
}
.next-step-card p {
    font-size: 0.9rem;
    color: var(--text-light);
    line-height: 1.6;
    margin-bottom: 0;
}
.next-step-card.primary-step {
    background-color: rgba(26, 54, 93, 0.1); /* Light primary blue background */
    border-left: 5px solid var(--primary-blue);
    box-shadow: var(--shadow-lg);
}
.primary-step h4 {
    color: var(--primary-blue);
    font-size: 1.3rem; /* Larger font for primary step title */
    font-weight: 700;
}
.primary-step p {
    font-weight: 500;
     color: var(--text-dark);
}
/* --- END OF NEW STYLES --- */
</style>
</head>
<body>
<div class="container">
<header><h1>Aviation Wildlife Risk Intelligence Platform</h1><p class="tagline">An integrated solution for risk assessment, trend analysis, and mitigation management, aligned with ICAO standards.</p></header>
<main>
<div id="main-content"><div class="welcome-section"><h2>Welcome to the Future of Aviation Safety</h2><p>This professional tool empowers airport operators, wildlife management teams, and aviation safety experts to proactively assess and mitigate birdstrike risks. By leveraging real-time data, dynamically enriching it with external sources for higher accuracy, and adhering to ICAO's globally recognized risk assessment methodology (Doc 9137), you can generate instant, data-driven wildlife risk profiles for any aerodrome. Make informed decisions, enhance your Wildlife Hazard Management Programme, and contribute to safer skies for everyone.</p><div class="attribution">Created by <a href="https://waleedmahrous.com/" target="_blank">Waleed MAHROUS, Stop BIRDSTRIKE</a></div></div><div class="input-section"><div class="input-field has-tooltip"><label for="icao-code"><span>ICAO Airport Code</span><div class="tooltip-icon">?</div></label><div class="tooltip-text"><h4>ICAO Airport Code</h4><p>The unique 4-letter international identifier for an airport used for precise geographic positioning and analysis.</p></div><input type="text" id="icao-code" placeholder="e.g., HECA, EGLL" maxlength="4" autocapitalize="characters"></div><div class="input-field has-tooltip"><label for="timeframe"><span>Analysis Timeframe</span><div class="tooltip-icon">?</div></label><div class="tooltip-text"><h4>Analysis Timeframe</h4><p>Determines the period for recent sightings analysis. The eBird API provides data for a maximum of 30 days, ideal for assessing current operational risk.</p></div><select id="timeframe"><option value="30" selected>Last 30 Days</option><option value="14">Last 14 Days</option><option value="7">Last 7 Days</option></select></div><button id="generate-btn" class="btn">Generate Profile</button></div><div id="status-container"></div></div>
<div id="results-wrapper" style="display: none;">
<div class="tabs"><div class="tab-link active" data-tab="dashboard">Risk Dashboard</div><div class="tab-link" data-tab="trends">Trend Analysis</div><div class="tab-link" data-tab="ibis">Strike Reporting & Analysis</div><div class="tab-link" data-tab="mitigation">Mitigation Strategy</div><div class="tab-link" data-tab="about">About & Help</div></div>
<div id="dashboard" class="tab-content active"><div class="result-card-header" style="margin-bottom: 1rem;"><div id="dashboard-header"></div><div class="header-buttons"><button id="home-btn" class="btn">New Analysis</button></div></div><div id="dashboard-content"></div>
<div class="result-card">
    <h3>Internal Airport Data (Historical)</h3>
    <p>Upload your airport's internal observation log here. The file **must** be a .csv and contain the following **exact lowercase** column headers: <strong>date, species, location, number, scene, severity, likelihood</strong></p>
    <ul style="font-size: 0.9rem; color: var(--text-light);">
        <li><strong>date:</strong> YYYY-MM-DD format (e.g., 2024-10-25)</li>
        <li><strong>species:</strong> Common name (e.g., "Rock Dove")</li>
        <li><strong>location:</strong> Coordinates as a single string: "latitude, longitude" (e.g., "25.2528, 55.3644")</li>
        <li><strong>number:</strong> A number (e.g., 1, 5, 20)</li>
        <li><strong>scene:</strong> Text description (e.g., "Runway 12L", "Flock on grass")</li>
        <li><strong>severity:</strong> Must be one of: "Very High", "High", "Medium", "Low", "Very Low" (case-sensitive)</li>
        <li><strong>likelihood:</strong> Must be one of: "Very High", "High", "Medium", "Low", "Very Low" (case-sensitive)</li>
    </ul>
    <div class="input-section" style="padding: 1rem; margin-top: 1rem;">
        <div class="input-field">
            <label for="csv-upload">Upload Internal .csv File</label>
            <input type="file" id="csv-upload" accept=".csv" style="padding: 0.65rem;">
        </div>
        <button id="upload-csv-btn" class="btn btn-secondary">Process File</button>
        <button id="clear-internal-data-btn" class="btn btn-danger">Clear Saved Data</button>
    </div>
    <div id="csv-status" style="margin-top: 1rem;"></div>
</div>

<div id="internal-matrix-container" class="result-card">
    </div>

<div id="internal-map-container" class="result-card" style="display: none;">
</div>
<div id="next-steps-guidance" class="result-card" style="display: none;">
    </div>
<div id="internal-trends-container" class="result-card" style="display: none;">
    <h3>Internal Data Trend Analysis</h3>
    <p style="font-size: 0.9rem; color: var(--text-light); border-left: 3px solid var(--primary-blue); padding-left: 1rem;">
       This graph visualizes trends from your uploaded internal data, categorized by risk level (based on internal matrix calculation). It shows the number of birds seen per day for Intolerable (Red), Tolerable (Yellow), and Acceptable (Green) risk species. Hover over data points to see the species reported for that category and day.
    </p>
    <div class="chart-wrapper" style="margin-top: 1rem;">
        <canvas id="internal-trends-chart"></canvas>
    </div>
</div>
</div>

<div id="trends" class="tab-content">
<div id="trends-airport-display" class="tab-airport-header"></div><div class="result-card"><div class="result-card-header"><h3>Sightings Trend (Last 30 Days)</h3><div class="header-buttons"><button class="btn back-to-dashboard-btn">Back to Dashboard</button></div></div><div class="chart-wrapper" style="margin-top: 1rem;"><canvas id="trends-chart"></canvas></div><p id="trends-caption"></p><div id="species-images-container"></div></div></div>
<div id="ibis" class="tab-content">
<div id="ibis-airport-display" class="tab-airport-header"></div>
<div class="result-card">
<div class="result-card-header">
<h3>ICAO IBIS Report & Analysis</h3>
<div class="toggle-container">
<label for="merge-ibis-data-toggle">Merge All Airport Data</label>
<label class="switch"><input type="checkbox" id="merge-ibis-data-toggle"><span class="slider"></span></label>
</div>
<div class="header-buttons">
<button class="btn back-to-dashboard-btn">Back to Dashboard</button>
<button class="btn btn-secondary" id="download-ibis-csv-btn">Download IBIS (CSV)</button>
<button class="btn btn-danger" id="clear-ibis-data-btn">Clear All Local Data</button>
</div>
</div>
<div class="airport-toggle-section">
<div id="ibis-dashboard-card"></div>
<h4>Select Airports for Analysis</h4>
<div id="ibis-airport-toggles" class="airport-toggle-grid"></div>
</div>
<p>Log wildlife strikes or significant observations using the ICAO-standard IBIS form below. Submitted data will automatically update the analysis charts, providing a real-time overview of your aerodrome's specific wildlife hazard landscape.</p>
<div class="form-section" id="ibis-filters"><h4>Filter Reports</h4><div class="input-section" style="padding:1rem; margin-top:1rem; justify-content: flex-start;"><div class="input-field"><label for="filter-start-date">Start Date</label><input type="date" id="filter-start-date"></div><div class="input-field"><label for="filter-end-date">End Date</label><input type="date" id="filter-end-date"></div><div class="input-field"><label for="filter-species">Species</label><select id="filter-species"><option value="">All</option></select></div><div class="input-field"><label for="filter-phase">Flight Phase</label><select id="filter-phase"><option value="">All</option></select></div><button id="apply-filters-btn" class="btn">Apply</button><button id="reset-filters-btn" class="btn btn-secondary">Reset</button></div></div><div id="ibis-form-container" class="form-section"><h4>New IBIS Report</h4><div id="ibis-form-grid"></div><button id="submit-ibis-btn" class="btn" style="margin-top: 1.5rem;">Submit Report</button><div id="ibis-status" style="margin-top: 1rem;"></div></div><div id="ibis-analysis-section" class="form-section"><h4 id="ibis-analysis-title">Internal Strike/Observation Analysis</h4><p id="ibis-analysis-subtitle">This dashboard visualizes all data submitted via the IBIS form above, providing insights into your local trends.</p><div class="ibis-charts-grid"><div class="chart-wrapper"><canvas id="ibis-strikes-by-month-chart"></canvas></div><div class="chart-wrapper"><canvas id="ibis-phase-chart"></canvas></div><div class="chart-wrapper"><canvas id="ibis-light-conditions-chart"></canvas></div><div class="chart-wrapper"><canvas id="ibis-species-chart"></canvas></div><div class="chart-wrapper"><canvas id="ibis-parts-struck-chart"></canvas></div><div class="chart-wrapper"><canvas id="ibis-parts-damaged-chart"></canvas></div></div></div>
</div>
</div>
<div id="mitigation" class="tab-content">
<div id="mitigation-airport-display" class="tab-airport-header"></div>
<div class="result-card">
<div class="result-card-header">
<h3>Mitigation Strategy Planner</h3>
<div class="toggle-container">
<label for="merge-mitigation-data-toggle">Merge All Airport Data</label>
<label class="switch"><input type="checkbox" id="merge-mitigation-data-toggle"><span class="slider"></span></label>
</div>
<div class="header-buttons">
<button class="btn back-to-dashboard-btn">Back to Dashboard</button>
<button class="btn btn-secondary" id="download-mitigation-csv-btn">Download Log (CSV)</button>
<button class="btn btn-danger" id="clear-mitigation-data-btn">Clear All Local Data</button>
</div>
</div>
<div class="airport-toggle-section">
<div id="mitigation-dashboard-card"></div>
<h4>Select Airports for Analysis</h4>
<div id="mitigation-airport-toggles" class="airport-toggle-grid"></div>
</div>
<div id="mitigation-intro"></div><div id="mitigation-flow"></div><div id="mitigation-example"></div><div id="mitigation-framework"></div><h4 style="margin-top: 2rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem;">Custom Mitigation Action Log</h4><p>Log all mitigation actions taken. This data will be saved and can be used to correlate actions with changes in wildlife activity on the Trend Analysis chart.</p><div class="input-section" style="padding: 1rem; margin-top: 1rem;"><div class="input-field"><label for="mitigation-date">Date</label><input type="date" id="mitigation-date"></div><div class="input-field"><label for="mitigation-type">Action Type</label><select id="mitigation-type"><option>Habitat Management (e.g., grass cutting)</option><option>Dispersal (e.g., pyrotechnics, distress calls)</option><option>Falconry/K9 Unit Deployed</option><option>Infrastructure Mod (e.g., netting)</option><option>Lethal Control (as per WHMP)</option><option>Other</option></select></div><div class="input-field"><label for="mitigation-owner">Action Owner</label><input type="text" id="mitigation-owner" placeholder="e.g., John D."></div><div class="input-field"><label for="mitigation-notes">Notes</label><input type="text" id="mitigation-notes" placeholder="e.g., 'West runway'"></div><button id="add-log-btn" class="btn">Add to Log</button></div><div id="log-status" style="margin-top: 1rem;"></div><h4 style="margin-top: 1.5rem;">Completed Actions Log</h4><div class="log-table-container"><table class="log-table"><thead><tr><th>Date</th><th>Action Type</th><th>Owner</th><th>Notes</th><th>Effectiveness (Strikes in next 7 days)</th></tr></thead><tbody id="log-table-body"></tbody></table></div>
</div>
</div>
<div id="about" class="tab-content"><div class="result-card"><div class="result-card-header"><h3>About & Help</h3><div class="header-buttons"><button class="btn back-to-dashboard-btn">Back to Dashboard</button></div></div><div class="form-section"><h4>About the Creator & Platform</h4><p>This Aviation Wildlife Risk Intelligence Platform was designed and developed by <strong>Waleed MAHROUS</strong>, a veterinarian with 15 years of dedicated experience in airport operations, consultancy, and wildlife hazard management. As the founder of <strong>Stop BIRDSTRIKE</strong>, his mission is to enhance aviation safety globally through innovative solutions, expert training, and the creation and implementation of effective Wildlife Hazard Management Programmes (WHMP).</p><p>This tool is a practical application of that mission, empowering aviation professionals with the data-driven insights needed to make informed decisions and proactively manage wildlife risks in accordance with the highest international standards.</p><ul><li><strong>Learn More:</strong> <a href="https://waleedmahrous.com/" target="_blank">waleedmahrous.com</a></li><li><strong>Contact Us:</strong> <a href="https://waleedmahrous.com/#contact-waleed-mahrous" target="_blank">Online Form</a> or via email at <a href="mailto:info@waleedmahrous.com">info@waleedmahrous.com</a></li></ul></div><div class="form-section"><h4>How to Use This Tool</h4><ul><li><strong>Risk Dashboard:</strong> Start by entering an airport's 4-letter ICAO code. The dashboard will generate an instant risk profile based on recent, real-world wildlife sightings from the eBird database, classifying species risk according to ICAO Doc 9137 methodology.</li><li><strong>Trend Analysis:</strong> This chart visualizes the external wildlife pressure over the last 30 days. Use it to identify seasonal patterns and evaluate the effectiveness of your Wildlife Hazard Management Programme by comparing it to your internal logs.</li><li><strong>Strike Reporting & Analysis:</strong> Use the ICAO IBIS form to log all internal strikes and significant observations. Your submitted data is saved locally and used to generate real-time analysis charts, helping you understand your airport's specific hazard landscape.</li><li><strong>Mitigation Strategy:</strong> Plan and log your mitigation actions. The app helps correlate these actions with changes in wildlife activity, providing feedback on their effectiveness.</li></ul></div></div></div>
</div>
</main>
</div>

<div class="modal-overlay" id="confirm-modal"><div class="modal-content"><h4>Confirm Action</h4><p id="confirm-modal-text">Are you sure you want to proceed?</p><div class="modal-buttons"><button class="btn btn-secondary" id="confirm-modal-cancel">Cancel</button><button class="btn btn-danger" id="confirm-modal-confirm">Confirm</button></div></div></div>

<div class="modal-overlay" id="override-modal">
    <div class="modal-content" style="max-width: 500px; text-align: left;">
        <h4 id="override-modal-title">Override Risk Rating</h4>
        <p>Manually set the risk rating for this species based on local expertise. This override will be saved for this airport only.</p>
        <div class="input-section" style="padding: 0; background: none; border: none; backdrop-filter: none; align-items: center;">
            <div class="input-field">
                <label for="override-severity">Severity</label>
                <select id="override-severity"></select>
            </div>
            <div class="input-field">
                <label for="override-likelihood">Likelihood</label>
                <select id="override-likelihood"></select>
            </div>
        </div>
        <div class="modal-buttons" style="margin-top: 2rem;">
            <button class="btn btn-secondary" id="override-modal-reset">Reset to Automatic</button>
            <button class="btn" id="override-modal-save">Save Changes</button>
            <button class="btn btn-danger" id="override-modal-cancel">Cancel</button>
        </div>
    </div>
</div>
<script>
</script>
<script>
document.addEventListener('contextmenu', event => event.preventDefault());
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
let myMap = null, myTrendsChart = null, airportDatabase = {};
let internalMap = null, currentInternalSpeciesData = null; // NEW
let currentSightings = [], currentProcessedData = null, currentAirport = null;
let ibisCharts = {};
let internalTrendsChart = null; // NEW: For the internal data trend chart
let riskOverrides = {};
let mitigationLog = {}, ibisReports = {};
let internalAirportData = {}; // NEW: For CSV upload data
const speciesDataCache = {};

const birdRiskData = { "Graylag Goose":{mass:3300,risk:"High"},"Canada Goose":{mass:5500,risk:"High"},"Egyptian Goose":{mass:2500,risk:"High"},"White Stork":{mass:3500,risk:"High"},"Black Stork":{mass:3000,risk:"High"},"Marabou Stork":{mass:6000,risk:"High"},"Great White Pelican":{mass:10000,risk:"High"},"Pink-backed Pelican":{mass:5500,risk:"High"},"Great Cormorant":{mass:3000,risk:"High"},"Lappet-faced Vulture":{mass:8000,risk:"High"},"White-backed Vulture":{mass:5500,risk:"High"},"Cape Vulture":{mass:9400,risk:"High"},"Griffon Vulture":{mass:8500,risk:"High"},"Steppe Eagle":{mass:3700,risk:"High"},"Booted Eagle":{mass:700,risk:"High"},"Tawny Eagle":{mass:2200,risk:"High"},"Verreaux's Eagle":{mass:4200,risk:"High"},"Martial Eagle":{mass:4600,risk:"High"},"African Fish Eagle":{mass:2800,risk:"High"},"Common Crane":{mass:5500,risk:"High"},"Demoiselle Crane":{mass:2500,risk:"High"},"Grey Crowned Crane":{mass:3500,risk:"High"},"Kori Bustard":{mass:12000,risk:"High"},"Great Bustard":{mass:10000,risk:"High"},"Kelp Gull":{mass:1000,risk:"High"},"Caspian Gull":{mass:1000,risk:"High"},"Great Black-backed Gull":{mass:1500,risk:"High"},"Helmeted Guineafowl":{mass:1300,risk:"High"},"Spur-winged Goose":{mass:6000,risk:"High"},"Common Shelduck":{mass:1200,risk:"High"},"Greater Flamingo":{mass:3500,risk:"High"},"Rock Dove":{mass:350,risk:"Medium"},"Rock Pigeon":{mass:350,risk:"Medium"},"Muscovy Duck":{mass:5000,risk:"Medium"},"Speckled Pigeon":{mass:300,risk:"Medium"},"Black-headed Gull":{mass:280,risk:"Medium"},"Slender-billed Gull":{mass:250,risk:"Medium"},"Cattle Egret":{mass:350,risk:"Medium"},"Little Egret":{mass:350,risk:"Medium"},"Grey Heron":{mass:1500,risk:"Medium"},"Squacco Heron":{mass:300,risk:"Medium"},"Black-crowned Night Heron":{mass:950,risk:"Medium"},"Striated Heron":{mass:200,risk:"Medium"},"Purple Heron":{mass:1000,risk:"Medium"},"Black-headed Heron":{mass:1200,risk:"Medium"},"Sacred Ibis":{mass:1500,risk:"Medium"},"Glossy Ibis":{mass:600,risk:"Medium"},"Eurasian Curlew":{mass:750,risk:"Medium"},"Black-tailed Godwit":{mass:280,risk:"Medium"},"Northern Lapwing":{mass:220,risk:"Medium"},"Spur-winged Lapwing":{mass:200,risk:"Medium"},"Blacksmith Lapwing":{mass:180,risk:"Medium"},"Common Kestrel":{mass:190,risk:"Medium"},"Lanner Falcon":{mass:600,risk:"Medium"},"Peregrine Falcon":{mass:750,risk:"Medium"},"Yellow-billed Kite":{mass:650,risk:"Medium"},"Black Kite":{mass:750,risk:"Medium"},"Common Buzzard":{mass:800,risk:"Medium"},"Pallid Harrier":{mass:350,risk:"Medium"},"Montagu's Harrier":{mass:300,risk:"Medium"},"Western Marsh Harrier":{mass:550,risk:"Medium"},"Spotted Eagle-Owl":{mass:650,risk:"Medium"},"Barn Owl":{mass:300,risk:"Medium"},"Long-crested Eagle":{mass:1100,risk:"Medium"},"Wahlberg's Eagle":{mass:700,risk:"Medium"},"Pied Crow":{mass:520,risk:"Medium"},"Hooded Crow":{mass:500,risk:"Medium"},"Brown-necked Raven":{mass:600,risk:"Medium"},"Fan-tailed Raven":{mass:700,risk:"Medium"},"European Starling":{mass:80,risk:"Medium"},"Red-winged Starling":{mass:120,risk:"Medium"},"Common Myna":{mass:110,risk:"Medium"},"Rose-ringed Parakeet":{mass:130,risk:"Medium"},"Laughing Dove":{mass:110,risk:"Medium"},"Namaqua Dove":{mass:40,risk:"Medium"},"Red-eyed Dove":{mass:250,risk:"Medium"},"African Openbill":{mass:1200,risk:"Medium"},"Hamerkop":{mass:470,risk:"Medium"},"Hadada Ibis":{mass:1200,risk:"Medium"},"African Spoonbill":{mass:1800,risk:"Medium"},"White-faced Whistling Duck":{mass:700,risk:"Medium"},"Fulvous Whistling Duck":{mass:750,risk:"Medium"},"Garganey":{mass:350,risk:"Medium"},"Northern Shoveler":{mass:600,risk:"Medium"},"Ferruginous Duck":{mass:550,risk:"Medium"},"Eurasian Wigeon":{mass:650,risk:"Medium"},"Mallard":{mass:1200,risk:"Medium"},"Yellow-billed Duck":{mass:900,risk:"Medium"},"Red-knobbed Coot":{mass:700,risk:"Medium"},"Common Moorhen":{mass:300,risk:"Medium"},"Water Thick-knee":{mass:320,risk:"Medium"},"Spotted Thick-knee":{mass:450,risk:"Medium"},"Crowned Lapwing":{mass:200,risk:"Medium"},"Senegal Lapwing":{mass:250,risk:"Medium"},"Collared Pratincole":{mass:80,risk:"Medium"},"Pin-tailed Sandgrouse":{mass:350,risk:"Medium"},"Chestnut-bellied Sandgrouse":{mass:250,risk:"Medium"},"African Green Pigeon":{mass:200,risk:"Medium"},"Great Spotted Cuckoo":{mass:120,risk:"Medium"},"Lilac-breasted Roller":{mass:100,risk:"Medium"},"European Roller":{mass:120,risk:"Medium"},"Green Wood Hoopoe":{mass:70,risk:"Medium"},"African Grey Hornbill":{mass:200,risk:"Medium"},"Red-billed Hornbill":{mass:150,risk:"Medium"},"Barn Swallow":{mass:19,risk:"Low"},"House Sparrow":{mass:28,risk:"Low"},"White Wagtail":{mass:22,risk:"Low"},"Yellow Wagtail":{mass:17,risk:"Low"},"Common Bulbul":{mass:35,risk:"Low"},"African Green Bee-eater":{mass:15,risk:"Low"},"European Bee-eater":{mass:55,risk:"Low"},"Little Bee-eater":{mass:15,risk:"Low"},"Crested Lark":{mass:40,risk:"Low"},"Desert Lark":{mass:25,risk:"Low"},"Common Swift":{mass:40,risk:"Low"},"Little Swift":{mass:20,risk:"Low"},"African Palm Swift":{mass:15,risk:"Low"},"House Martin":{mass:18,risk:"Low"},"Sand Martin":{mass:14,risk:"Low"},"Zitting Cisticola":{mass:10,risk:"Low"},"Graceful Prinia":{mass:7,risk:"Low"},"Sardinian Warbler":{mass:11,risk:"Low"},"Willow Warbler":{mass:8,risk:"Low"},"Common Chiffchaff":{mass:7,risk:"Low"},"Spotted Flycatcher":{mass:16,risk:"Low"},"Northern Wheatear":{mass:25,risk:"Low"},"Common Redstart":{mass:15,risk:"Low"},"Southern Red Bishop":{mass:20,risk:"Low"},"Village Weaver":{mass:38,risk:"Low"},"Red-billed Quelea":{mass:18,risk:"Low"},"Common Waxbill":{mass:8,risk:"Low"},"African Silverbill":{mass:9,risk:"Low"},"Cape Sparrow":{mass:26,risk:"Low"},"Cape Wagtail":{mass:20,risk:"Low"},"African Pied Wagtail":{mass:25,risk:"Low"},"Fork-tailed Drongo":{mass:40,risk:"Low"},"Southern Fiscal":{mass:40,risk:"Low"},"Bokmakierie":{mass:65,risk:"Low"},"Cape Robin-Chat":{mass:28,risk:"Low"},"Karoo Thrush":{mass:70,risk:"Low"},"Olive Thrush":{mass:65,risk:"Low"},"Cape White-eye":{mass:10,risk:"Low"},"Malachite Sunbird":{mass:12,risk:"Low"},"Southern Double-collared Sunbird":{mass:9,risk:"Low"},"Red-chested Sunbird":{mass:10,risk:"Low"},"Cinnamon-breasted Bunting":{mass:15,risk:"Low"},"Lark-like Bunting":{mass:18,risk:"Low"},"White-browed Sparrow-Weaver":{mass:45,risk:"Low"},"Sociable Weaver":{mass:28,risk:"Low"},"Scaly-feathered Weaver":{mass:15,risk:"Low"}};
const demoData = { airport: { icao: 'OMDB', name: 'Dubai International Airport', lat: '25.2528', lon: '55.3644' }, observations: [].concat(...[{comName:"Rock Dove",howMany:20,lat:25.26,lng:55.37,obsDt:"2025-10-09 10:00"},{comName:"Laughing Dove",howMany:15,lat:25.24,lng:55.35,obsDt:"2025-10-08 11:00"},{comName:"White Stork",howMany:2,lat:25.28,lng:55.4,obsDt:"2025-10-07 12:00"},{comName:"Common Myna",howMany:10,lat:25.25,lng:55.36,obsDt:"2025-10-06 13:00"},{comName:"House Sparrow",howMany:25,lat:25.23,lng:55.34,obsDt:"2025-10-05 14:00"},{comName:"Rose-ringed Parakeet",howMany:8,lat:25.27,lng:55.38,obsDt:"2025-10-04 15:00"},{comName:"Black Kite",howMany:1,lat:25.3,lng:55.42,obsDt:"2025-10-03 16:00"}].map(o=>Array(o.howMany).fill(o))) };
const SEVERITY_LEVELS = ['Very Low', 'Low', 'Medium', 'High', 'Very High'];
const LIKELIHOOD_LEVELS = ['Very Low', 'Low', 'Medium', 'High', 'Very High'];
const riskColorMap = [ ['acceptable', 'acceptable', 'acceptable', 'acceptable', 'tolerable' ], ['acceptable', 'acceptable', 'acceptable', 'tolerable', 'intolerable'], ['acceptable', 'acceptable', 'tolerable', 'intolerable','intolerable'], ['tolerable', 'tolerable', 'intolerable','intolerable','intolerable'], ['tolerable', 'intolerable','intolerable','intolerable','intolerable'] ];
const ibisFormFields = [ { id: 'localDate', label: 'Local Date', type: 'date', required: true }, { id: 'localTime', label: 'Local Time', type: 'time', required: true }, { id: 'flightPhase', label: 'Flight Phase', type: 'select', options: ['Approach', 'Climb', 'Descent', 'En Route', 'Landing', 'Manoeuvring', 'Parked', 'Standing', 'Take-off', 'Taxi'], required: true }, { id: 'wildlifeSpecies', label: 'Wildlife Species', type: 'dynamic-select', required: true }, { id: 'birdsSeen', label: 'Number of Birds Seen', type: 'select', options: ['1', '2-10', '11-100', '>100'], required: true }, { id: 'birdsStruck', label: 'Number of Birds Struck', type: 'select', options: ['1', '2-10', '11-100', '>100'], required: true }, { id: 'heightFt', label: 'Height (ft AGL)', type: 'number', placeholder: 'e.g., 500' }, { id: 'speedKt', label: 'Speed (kt IAS)', type: 'number', placeholder: 'e.g., 140' }, { id: 'lightConditions', label: 'Light Conditions', type: 'select', options: ['Dawn', 'Daylight', 'Dusk/Twilight', 'Night'] }, { id: 'phenomenonType', label: 'Weather', type: 'select', options: ['Clear', 'Fog', 'Rain', 'Snow'] }, { id: 'pilotAdvised', label: 'Pilot Advised of Birds?', type: 'select', options: ['Yes', 'No', 'N/A'] }, { id: 'aircraftModel', label: 'Aircraft Model', type: 'text', placeholder: 'e.g., A320' }, ];
const partFields = [ { id: 'radome', label: 'Radome' }, { id: 'windshield', label: 'Windshield' }, { id: 'nose', label: 'Nose' }, { id: 'engine1', label: 'Engine 1' }, { id: 'engine2', label: 'Engine 2' }, { id: 'engine3', label: 'Engine 3' }, { id: 'engine4', label: 'Engine 4' }, { id: 'propeller', label: 'Propeller' }, { id: 'wingRotor', label: 'Wing or Rotor (HEL)' }, { id: 'fuselage', label: 'Fuselage' }, { id: 'landingGear', label: 'Landing Gear' }, { id: 'tail', label: 'Tail' }, { id: 'lights', label: 'Lights' }, { id: 'other', label: 'Others' }];
const generateBtn = document.getElementById('generate-btn'), icaoInput = document.getElementById('icao-code'), addLogBtn = document.getElementById('add-log-btn'), statusContainer = document.getElementById('status-container'), submitIbisBtn = document.getElementById('submit-ibis-btn'), clearIbisDataBtn = document.getElementById('clear-ibis-data-btn'), clearMitigationDataBtn = document.getElementById('clear-mitigation-data-btn'), confirmModal = document.getElementById('confirm-modal'), confirmModalCancel = document.getElementById('confirm-modal-cancel'), confirmModalConfirm = document.getElementById('confirm-modal-confirm'), applyFiltersBtn = document.getElementById('apply-filters-btn'), resetFiltersBtn = document.getElementById('reset-filters-btn'), mergeIbisToggle = document.getElementById('merge-ibis-data-toggle'), mergeMitigationToggle = document.getElementById('merge-mitigation-data-toggle');
generateBtn.addEventListener('click', handleProfileGeneration);
icaoInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') handleProfileGeneration(); });
addLogBtn.addEventListener('click', addMitigationLog);
submitIbisBtn.addEventListener('click', submitIbisReport);
applyFiltersBtn.addEventListener('click', applyIbisFilters);
resetFiltersBtn.addEventListener('click', resetIbisFilters);
// PASTE THIS NEW CODE BLOCK
// NEW: Specific event listeners for each clear button
clearIbisDataBtn.addEventListener('click', (event) => {
    showConfirmModal('Are you sure you want to permanently delete ALL locally stored IBIS reports for ALL airports? This action cannot be undone.', clearIbisData, event);
});

clearMitigationDataBtn.addEventListener('click', (event) => {
    showConfirmModal('Are you sure you want to permanently delete ALL locally stored Mitigation logs for ALL airports? This action cannot be undone.', clearMitigationData, event);
});
confirmModalCancel.addEventListener('click', hideConfirmModal);
document.querySelectorAll('.tab-link').forEach(link => link.addEventListener('click', () => openTab(link.dataset.tab)));
// NEW: Event listeners for CSV upload
document.getElementById('upload-csv-btn').addEventListener('click', handleCSVUpload);
document.getElementById('clear-internal-data-btn').addEventListener('click', (event) => {
    if (!currentAirport) {
        showStatusMessage('csv-status', 'No airport is currently loaded.', 'error');
        return;
    }
    const confirmMessage = `Are you sure you want to permanently delete the uploaded internal data for ${currentAirport.name} (${currentAirport.icao})? This action cannot be undone.`;
    showConfirmModal(confirmMessage, clearInternalData, event);
});
document.getElementById('download-ibis-csv-btn').addEventListener('click', downloadIbisCSV);
document.getElementById('download-mitigation-csv-btn').addEventListener('click', downloadMitigationCSV);
mergeIbisToggle.addEventListener('change', () => { mergeMitigationToggle.checked = mergeIbisToggle.checked; refreshLocalDataView(); });
mergeMitigationToggle.addEventListener('change', () => { mergeIbisToggle.checked = mergeMitigationToggle.checked; refreshLocalDataView(); });
// --- CENTRALIZED EVENT LISTENERS ---
document.body.addEventListener('click', (event) => {
    // Handle "New Analysis" button click
    if (event.target.id === 'home-btn') {
        resetToHome();
    }
    
    // Handle all "Back to Dashboard" buttons
    if (event.target.classList.contains('back-to-dashboard-btn')) {
        openTab('dashboard');
    }

    // Handle CSV download for map data
    if (event.target.id === 'download-csv-btn' && currentAirport) {
        downloadCSV(currentAirport.name);
    }

    // Handle KML download for map data
    if (event.target.id === 'download-kml-btn' && currentAirport) {
        downloadKML(currentAirport.name);
    }
// NEW: Handle Internal CSV download
    if (event.target.id === 'download-internal-csv-btn' && currentAirport) {
        downloadInternalCSV(currentAirport.name);
    }

    // NEW: Handle Internal KML download
    if (event.target.id === 'download-internal-kml-btn' && currentAirport) {
        downloadInternalKML(currentAirport.name);
    }
});
// --- NEW LOGIC FOR DELETING MITIGATION LOGS ---
const logTableBody = document.getElementById('log-table-body');
if (logTableBody) {
    logTableBody.addEventListener('click', (event) => {
        if (event.target.classList.contains('delete-log-btn')) {
            const timestamp = event.target.dataset.timestamp;
            showConfirmModal('Are you sure you want to delete this log entry?', () => {
                deleteMitigationLogEntry(timestamp);
            }, event);
        }
    });
}

function deleteMitigationLogEntry(timestamp) {
    if (!currentAirport || !mitigationLog[currentAirport.icao]) return;

    // Filter out the log entry that matches the timestamp
    const updatedLog = mitigationLog[currentAirport.icao].filter(log => log.timestamp !== timestamp);
    mitigationLog[currentAirport.icao] = updatedLog;

    saveMitigationLogToLocal();
    refreshLocalDataView(); // This will re-render the table and update the chart annotations
    showStatusMessage('log-status', 'Log entry deleted successfully.', 'demo');
}

// NEW: Airport toggle state management
let airportToggleState = {
  ibis: {},
  mitigation: {}
};

(async () => { showStatus("Loading airport database...", true); try { const response = await fetch('https://raw.githubusercontent.com/mwgg/Airports/master/airports.json'); if (!response.ok) throw new Error('Network response was not ok'); airportDatabase = await response.json(); statusContainer.innerHTML = ''; } catch (error) { console.error("Failed to load airport database:", error); showStatus("Error: Could not load the airport database. Please check your internet connection and refresh the page.", false, 'error'); } generateIbisForm(); loadDataFromLocal(); })();

function showConfirmModal(text, onConfirm, event) { 
    document.getElementById('confirm-modal-text').textContent = text; 
    confirmModalConfirm.onclick = () => { 
        onConfirm(); 
        hideConfirmModal(); 
    }; 
const modalContent = confirmModal.querySelector('.modal-content');

// Make modal temporarily visible but hidden to measure it
confirmModal.style.visibility = 'hidden';
confirmModal.style.display = 'flex';

if (event) {
    const modalWidth = modalContent.offsetWidth;
    const modalHeight = modalContent.offsetHeight;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const padding = 10; // 10px padding from cursor and screen edge

    // Calculate Top position
    let topPos = event.clientY + padding;
    if (topPos + modalHeight + padding > vh) {
        // If it goes off-bottom, position it above the cursor
        topPos = event.clientY - modalHeight - padding;
    }
    // Ensure it doesn't go off-top
    topPos = Math.max(padding, topPos); 

    // Calculate Left position
    let leftPos = event.clientX + padding;
    if (leftPos + modalWidth + padding > vw) {
        // If it goes off-right, position it left of the cursor
        leftPos = event.clientX - modalWidth - padding;
    }
    // Ensure it doesn't go off-left
    leftPos = Math.max(padding, leftPos);

    modalContent.style.top = `${topPos}px`;
    modalContent.style.left = `${leftPos}px`;
    modalContent.style.transform = ''; // Clear any centering transforms
} else {
    // Fallback to center if event is missing
    modalContent.style.top = '50%';
    modalContent.style.left = '50%';
    modalContent.style.transform = 'translate(-50%, -50%)';
}

// Make modal visible at its new position
confirmModal.style.visibility = 'visible';
    
}

function hideConfirmModal() { confirmModal.style.display = 'none'; }
function loadDataFromLocal() { 
    try { 
        const storedMitigationLog = localStorage.getItem('mitigationLog'); 
        if (storedMitigationLog) { 
            mitigationLog = JSON.parse(storedMitigationLog) || {}; 
        } 
        const storedIbisReports = localStorage.getItem('ibisReports'); 
        if (storedIbisReports) { 
            ibisReports = JSON.parse(storedIbisReports) || {}; 
        } 
        const storedToggleState = localStorage.getItem('airportToggleState'); 
        if (storedToggleState) {
            airportToggleState = JSON.parse(storedToggleState);
        }
        const storedOverrides = localStorage.getItem('riskOverrides');
        if (storedOverrides) {
            riskOverrides = JSON.parse(storedOverrides) || {};
        }
const storedInternalData = localStorage.getItem('internalAirportData'); // NEW
        if (storedInternalData) { // NEW
            internalAirportData = JSON.parse(storedInternalData) || {}; // NEW
        } // NEW
    } catch (e) { 
        console.error("Error loading data from localStorage:", e); 
        mitigationLog = {}; 
        ibisReports = {}; 
        airportToggleState = { ibis: {}, mitigation: {} }; 
        riskOverrides = {};
internalAirportData = {}; // NEW
    } 
}
function loadAirportSpecificData(icao) { 
    if (!ibisReports[icao]) ibisReports[icao] = []; 
    if (!mitigationLog[icao]) mitigationLog[icao] = [];  
    if (!riskOverrides[icao]) riskOverrides[icao] = {};
    if (!internalAirportData[icao]) internalAirportData[icao] = [];

    if (!airportToggleState.ibis[icao]) airportToggleState.ibis[icao] = true;
    if (!airportToggleState.mitigation[icao]) airportToggleState.mitigation[icao] = true;
    
    saveToggleStateToLocal();
    refreshLocalDataView();
    
    // Check if there is internal data for this airport
    const data = internalAirportData[icao];
    if (data && data.length > 0) {
        // Check if any row has valid location data
        const hasValidLocation = data.some(row => row.lat !== null && row.lng !== null);
        // Regenerate the internal matrix and map from saved data
        generateInternalRiskMatrix(data, hasValidLocation);
    } else {
        // No data for this airport - clear all internal data displays
        clearInternalDataDisplays();
    }
}

function clearInternalDataDisplays() {
    // Clear the internal matrix
    const internalMatrixContainer = document.getElementById('internal-matrix-container');
    if (internalMatrixContainer) {
        internalMatrixContainer.innerHTML = '';
    }
    
    // Clear and hide the internal map
    if (internalMap) {
        internalMap.remove();
        internalMap = null;
    }
    const internalMapContainer = document.getElementById('internal-map-container');
    if (internalMapContainer) {
        internalMapContainer.innerHTML = '';
        internalMapContainer.style.display = 'none';
    }
    
    // Clear and hide the internal trends chart
    if (internalTrendsChart) {
        internalTrendsChart.destroy();
        internalTrendsChart = null;
    }
    const internalTrendsContainer = document.getElementById('internal-trends-container');
    if (internalTrendsContainer) {
        internalTrendsContainer.style.display = 'none';
    }
    
    // Hide the next steps container
    const nextStepsContainer = document.getElementById('next-steps-guidance');
    if (nextStepsContainer) {
        nextStepsContainer.style.display = 'none';
    }
    
    // Clear any status messages in the CSV section
    const csvStatus = document.getElementById('csv-status');
    if (csvStatus) {
        csvStatus.innerHTML = '';
    }
}

function saveMitigationLogToLocal() { try { localStorage.setItem('mitigationLog', JSON.stringify(mitigationLog)); } catch (e) { console.error("Error saving mitigation log to localStorage:", e); } }
function saveIbisReportsToLocal() { try { localStorage.setItem('ibisReports', JSON.stringify(ibisReports)); } catch (e) { console.error("Error saving IBIS reports to localStorage:", e); } }
// NEW: Save internal CSV data
function saveInternalDataToLocal() { try { localStorage.setItem('internalAirportData', JSON.stringify(internalAirportData)); } catch (e) { console.error("Error saving internal data to localStorage:", e); } }
// NEW: Save toggle state
function saveToggleStateToLocal() { try { localStorage.setItem('airportToggleState', JSON.stringify(airportToggleState)); } catch (e) { console.error("Error saving toggle state to localStorage:", e); } }
function saveOverridesToLocal() {
    try {
        localStorage.setItem('riskOverrides', JSON.stringify(riskOverrides));
    } catch (e) {
        console.error("Error saving overrides to localStorage:", e);
    }
}
// PASTE THESE TWO NEW FUNCTIONS

function clearIbisData() {
    localStorage.removeItem('ibisReports');
    ibisReports = {};
    if(currentAirport) {
        loadAirportSpecificData(currentAirport.icao);
    } else {
        refreshLocalDataView();
    }
    showStatusMessage('ibis-status', 'All IBIS report data has been cleared.', 'demo');
}

function clearMitigationData() {
    localStorage.removeItem('mitigationLog');
    mitigationLog = {};
    if(currentAirport) {
        loadAirportSpecificData(currentAirport.icao);
    } else {
        refreshLocalDataView();
    }
    showStatusMessage('log-status', 'All mitigation log data has been cleared.', 'demo');
}

function clearInternalData() {
    if (!currentAirport) {
        showStatusMessage('csv-status', 'No airport is currently loaded.', 'error');
        return;
    }
    
    // Only clear data for the CURRENT airport
    const airportIcao = currentAirport.icao;
    const airportName = currentAirport.name;
    
    // Remove only this airport's data
    if (internalAirportData[airportIcao]) {
        delete internalAirportData[airportIcao];
    }
    
    // Save the updated data (other airports remain intact)
    saveInternalDataToLocal();
    
    // Clear the visual displays
    currentInternalSpeciesData = null;
    
    // Clear the internal matrix container
    const internalMatrixContainer = document.getElementById('internal-matrix-container');
    if (internalMatrixContainer) internalMatrixContainer.innerHTML = '';
    
    // Hide the "Next Steps" container
    const nextStepsContainer = document.getElementById('next-steps-guidance');
    if (nextStepsContainer) nextStepsContainer.style.display = 'none';
    
    // Clear internal trends chart
    if (internalTrendsChart) {
        internalTrendsChart.destroy();
        internalTrendsChart = null;
    }
    const internalTrendsContainer = document.getElementById('internal-trends-container');
    if (internalTrendsContainer) internalTrendsContainer.style.display = 'none';

    // Clear internal map
    if (internalMap) {
        internalMap.remove();
        internalMap = null;
    }
    const internalMapContainer = document.getElementById('internal-map-container');
    if (internalMapContainer) {
        internalMapContainer.innerHTML = '';
        internalMapContainer.style.display = 'none';
    }
    
    // Show success message with airport-specific information
    showStatusMessage('csv-status', `Internal data cleared for ${airportName} (${airportIcao}). Data for other airports remains saved.`, 'demo');
}

async function handleProfileGeneration() { const icao = document.getElementById('icao-code').value.toUpperCase().trim(), timeframe = document.getElementById('timeframe').value; if (!icao || icao.length !== 4) return showStatus("Please enter a valid 4-letter ICAO code.", false, 'error'); if (Object.keys(airportDatabase).length === 0) return showStatus("Airport database is not loaded. Please refresh the page to try again.", false, 'error'); const airport = airportDatabase[icao]; if (!airport) return showStatus(`Airport with ICAO code '${icao}' not found.`, false, 'error'); try { showStatus(`Fetching bird sightings for ${airport.name}...`, true); document.getElementById('main-content').style.display = 'none'; const observations = await fetchBirdData(airport.lat, airport.lon, timeframe); if (!observations || observations.length === 0) { showStatus(`No recent bird sightings found near ${airport.name} (${airport.icao}).`, false, 'error'); document.getElementById('main-content').style.display = 'block'; return; } currentAirport = airport; currentSightings = observations; currentProcessedData = await processBirdData(observations, airport); displayAllResults(currentProcessedData, observations, airport, timeframe); mergeIbisToggle.checked = false; mergeMitigationToggle.checked = false; loadAirportSpecificData(airport.icao); statusContainer.innerHTML = ''; document.getElementById('results-wrapper').style.display = 'block'; } catch (error) { console.error("API Fetch or Processing Error:", error); statusContainer.innerHTML = `<p class="status-message demo">⚠️ Could not connect to the live eBird database. Displaying a demonstration profile for Dubai (OMDB).</p>`; document.getElementById('main-content').style.display = 'none'; currentAirport = demoData.airport; currentSightings = demoData.observations; currentProcessedData = await processBirdData(demoData.observations, demoData.airport); displayAllResults(currentProcessedData, demoData.observations, demoData.airport, 30); mergeIbisToggle.checked = false; mergeMitigationToggle.checked = false; loadAirportSpecificData(demoData.airport.icao); document.getElementById('results-wrapper').style.display = 'block'; } }

// REPLACE the old displayAllResults function with this one
function displayAllResults(data, observations, airport, timeframe) {
    if (myMap) myMap.remove();
    if (myTrendsChart) myTrendsChart.destroy();

    // This is the new code that adds the airport name to each tab
    const airportDisplayName = `Currently Viewing: ${airport.name} (${airport.icao})`;
    document.getElementById('trends-airport-display').textContent = airportDisplayName;
    document.getElementById('ibis-airport-display').textContent = airportDisplayName;
    document.getElementById('mitigation-airport-display').textContent = airportDisplayName;

    displayDashboard(data, airport, timeframe);
    displayMitigationContent(data);
    updateIbisSpeciesDropdown(data.allSpecies);

    // The map and chart are now rendered after a short delay to ensure the page is ready
    setTimeout(async () => {
        displaySightingsMap(observations, parseFloat(airport.lat), parseFloat(airport.lon), airport.name, data, timeframe);
        await displayTrendsChart(observations, data.allSpecies, timeframe);
        updateMitigationAnnotations();
    }, 100);
}
async function fetchBirdData(lat, lon, timeframe) {
    // Call through our secure serverless function
    const url = `/api/fetch-birds?lat=${lat}&lng=${lon}&dist=30&back=${timeframe}`;
    const response = await fetch(url);
    
    if (!response.ok) {
        throw new Error(`API error: ${response.status} ${response.statusText}`);
    }
    return await response.json();
}
async function getSpeciesData(speciesName) { if (speciesDataCache[speciesName]) return speciesDataCache[speciesName]; if (birdRiskData[speciesName] && birdRiskData[speciesName].mass) { const data = { mass: birdRiskData[speciesName].mass, isFlocking: birdRiskData[speciesName].risk === 'High', source: 'Internal DB', confidence: 'High' }; speciesDataCache[speciesName] = data; return data; } const wikiData = await fetchEnhancedBirdData(speciesName); speciesDataCache[speciesName] = wikiData; return wikiData; }
async function fetchEnhancedBirdData(speciesName) { try { const url = `https://en.wikipedia.org/w/api.php?action=parse&page=${encodeURIComponent(speciesName)}&prop=wikitext&format=json&origin=*`; const response = await fetch(url); const data = await response.json(); if (data.error) { throw new Error(data.error.info); } const wikitext = data.parse.wikitext['*']; const mass = parseMassFromWikitext(wikitext); const isFlocking = parseFlockingFromWikitext(wikitext); if (mass !== null) return { mass, isFlocking, source: 'Wikipedia', confidence: 'Medium' }; } catch (error) { console.warn(`Could not fetch or parse Wikipedia data for ${speciesName}:`, error); } return { mass: null, isFlocking: false, source: 'Estimated', confidence: 'Low' }; }
function parseMassFromWikitext(text) { const massRegex = /\|\|s*(?:mass|weight)\|s*=\s*(?:\{\{convert\|)?([\d\.\,–—-]+)(?:\s*\|)?(?:g|kg)?/i; const match = text.match(massRegex); if (!match || !match[1]) return null; let massStr = match[1].split(/[-–—]/)[0].trim(), mass = parseFloat(massStr.replace(',', '.')); const context = text.substring(match.index, match.index + 50).toLowerCase(); if (context.includes('kg') || (!context.includes('g') && mass < 100)) mass *= 1000; return isNaN(mass) ? null : mass; }
async function processBirdData(observations, airport) {
    const speciesCounts = {};
observations.forEach(obs => {
    // This line now adds the number of birds, not just "1"
    speciesCounts[obs.comName] = (speciesCounts[obs.comName] || 0) + (obs.howMany || 1);
});
// Calculate the true total number of individual bird sightings
const totalIndividualSightings = observations.reduce((sum, obs) => sum + (obs.howMany || 1), 0);
    const sortedSpecies = Object.entries(speciesCounts).sort(([, a], [, b]) => b - a);
    const totalUniqueSpecies = sortedSpecies.length;
    showStatus(`Enriching data for ${totalUniqueSpecies} species...`, true);

    const airportOverrides = riskOverrides[airport.icao] || {};

    const allSpeciesData = await Promise.all(sortedSpecies.map(async ([name, count], index) => {
        const enhancedData = await getSpeciesData(name);
        let severity = enhancedData.mass ? getSeverityByMass(enhancedData.mass) : estimateSeverityByName(name).risk;
        const cutoffs = {
            'Very High': Math.ceil(totalUniqueSpecies * 0.05),
            'High': Math.ceil(totalUniqueSpecies * 0.20),
            'Moderate': Math.ceil(totalUniqueSpecies * 0.50),
            'Low': Math.ceil(totalUniqueSpecies * 0.80)
        };
        let likelihoodIndex;
        if (index < cutoffs['Very High']) likelihoodIndex = 4;
        else if (index < cutoffs['High']) likelihoodIndex = 3;
        else if (index < cutoffs['Moderate']) likelihoodIndex = 2;
        else if (index < cutoffs['Low']) likelihoodIndex = 1;
        else likelihoodIndex = 0;
        if (enhancedData.isFlocking && likelihoodIndex < 4) likelihoodIndex++;
        
        let likelihood = LIKELIHOOD_LEVELS[likelihoodIndex];
        let source = enhancedData.source;

        // Apply manual override if it exists
        if (airportOverrides[name]) {
            severity = airportOverrides[name].severity;
            likelihood = airportOverrides[name].likelihood;
            source = 'Manually Adjusted';
        }

        return { name, likelihood, severity, source };
    }));

    const matrixData = {};
    SEVERITY_LEVELS.forEach(sev => LIKELIHOOD_LEVELS.forEach(lik => matrixData[`${sev}-${lik}`] = []));
    let intolerableSpecies = new Set(),
        tolerableSpecies = new Set(),
        acceptableSpecies = new Set();

    allSpeciesData.forEach(species => {
        matrixData[`${species.severity}-${species.likelihood}`]?.push({ name: species.name, source: species.source });
        const category = getRiskCategory(species.severity, species.likelihood);
        if (category === 'intolerable') intolerableSpecies.add(species.name);
        else if (category === 'tolerable') tolerableSpecies.add(species.name);
        else if (category === 'acceptable') acceptableSpecies.add(species.name);
    });

    let sightingsInCriticalZone = 0;
    const speciesInCriticalZone = { intolerable: new Set(), tolerable: new Set(), acceptable: new Set() };
    if (airport && airport.lat && airport.lon) {
        const airportLat = parseFloat(airport.lat),
            airportLon = parseFloat(airport.lon);
        const speciesRiskMap = new Map(allSpeciesData.map(s => [s.name, getRiskCategory(s.severity, s.likelihood)]));
        observations.forEach(obs => {
            if (getDistance(airportLat, airportLon, obs.lat, obs.lng) <= 13) {
                sightingsInCriticalZone++;
                const category = speciesRiskMap.get(obs.comName);
                if (category && speciesInCriticalZone[category]) speciesInCriticalZone[category].add(obs.comName);
            }
        });
    }
    return {
        totalObservations: totalIndividualSightings, // Use the new, correct total
        totalUniqueSpecies,
        criticalSpecies: Array.from(intolerableSpecies),
        tolerableSpecies: Array.from(tolerableSpecies),
        acceptableSpecies: Array.from(acceptableSpecies),
        sightingsInCriticalZone,
        speciesInCriticalZone: {
            intolerable: Array.from(speciesInCriticalZone.intolerable),
            tolerable: Array.from(speciesInCriticalZone.tolerable),
            acceptable: Array.from(speciesInCriticalZone.acceptable),
        },
        matrixData,
        allSpecies: allSpeciesData
    };
}
function showStatus(message, showLoader = false, type = 'loading') { let loaderHtml = showLoader ? '<div class="loader"></div>' : ''; document.getElementById('results-wrapper').style.display = 'none'; statusContainer.innerHTML = `${loaderHtml}<p class="status-message ${type}">${message}</p>`; }
function displayDashboard(data, airport, timeframe) {document.getElementById('results-wrapper').style.display = 'block';
    document.getElementById('main-content').style.display = 'none'; document.getElementById('dashboard-header').innerHTML = `<h2>Risk Profile: ${airport.name} (${airport.icao})</h2><p>Analysis based on ${data.totalObservations} sightings of ${data.totalUniqueSpecies} species within 30km over the last ${timeframe} days. Data sourced from <a href="https://ebird.org/home" target="_blank">eBird.org</a> and enriched using external databases.</p>`; document.getElementById('dashboard-content').innerHTML = `<div class="dashboard-grid"><div class="stat-card intolerable"><div class="stat-value">${data.criticalSpecies.length}</div><div class="stat-label"><span>Intolerable Risk Species</span></div></div><div class="stat-card tolerable"><div class="stat-value">${data.tolerableSpecies.length}</div><div class="stat-label"><span>Tolerable Risk Species</span></div></div><div class="stat-card acceptable"><div class="stat-value">${data.acceptableSpecies.length}</div><div class="stat-label"><span>Acceptable Risk Species</span></div></div><div class="stat-card neutral"><div class="stat-value">${data.totalUniqueSpecies}</div><div class="stat-label"><span>Total Unique Species</span></div></div><div class="stat-card neutral"><div class="stat-value">${data.totalObservations}</div><div class="stat-label"><span>Total Sightings</span></div></div><div class="stat-card neutral"><div class="stat-value">${data.sightingsInCriticalZone}</div><div class="stat-label"><span>Sightings within 13km</span></div></div></div><div id="critical-species-container" class="result-card species-tag-container"></div><div id="tolerable-species-container" class="result-card species-tag-container"></div><div id="acceptable-species-container" class="result-card species-tag-container"></div><div id="critical-species-13km-container" class="result-card species-tag-container"></div><div class="results-layout"><div id="matrix-container" class="result-card"></div><div id="methodology-container" class="result-card"></div><div id="map-container" class="result-card"></div></div>`; const criticalContainer = document.getElementById('critical-species-container'); if (data.criticalSpecies.length > 0) { criticalContainer.innerHTML = `<h3>Identified Critical Risk Species</h3><div class="content">${data.criticalSpecies.map(name =>` <span class="species-tag intolerable-tag">${name}</span>`).join('')}</div>`; } else { criticalContainer.style.display = 'none'; } const tolerableContainer = document.getElementById('tolerable-species-container'); if (data.tolerableSpecies.length > 0) { tolerableContainer.innerHTML = `<h3>Identified Tolerable Risk Species</h3><div class="content">${data.tolerableSpecies.map(name =>` <span class="species-tag tolerable-tag">${name}</span>`).join('')}</div>`; } else { tolerableContainer.style.display = 'none'; } const acceptableContainer = document.getElementById('acceptable-species-container'); if (data.acceptableSpecies.length > 0) { acceptableContainer.innerHTML = `<h3>Identified Acceptable Risk Species</h3><div class="content">${data.acceptableSpecies.map(name =>` <span class="species-tag acceptable-tag">${name}</span>`).join('')}</div>`; } else { acceptableContainer.style.display = 'none'; } const critical13kmContainer = document.getElementById('critical-species-13km-container'); if (data.speciesInCriticalZone.intolerable.length > 0 || data.speciesInCriticalZone.tolerable.length > 0 || data.speciesInCriticalZone.acceptable.length > 0) { critical13kmContainer.style.display = 'block'; critical13kmContainer.innerHTML = `<h3>Species Sighted Within 13km Critical Zone</h3><div class="content">${data.speciesInCriticalZone.intolerable.map(name =>` <span class="species-tag intolerable-tag">${name}</span>`).join('')}${data.speciesInCriticalZone.tolerable.map(name =>` <span class="species-tag tolerable-tag">${name}</span>`).join('')}${data.speciesInCriticalZone.acceptable.map(name =>` <span class="species-tag acceptable-tag">${name}</span>`).join('')}</div>`; } else { critical13kmContainer.style.display = 'none'; } displayRiskMatrix(data); displayMethodology(data); }
// --- UPDATED displaySightingsMap ---
function displaySightingsMap(observations, lat, lon, airportName, data, timeframe) {
    const mapContainer = document.getElementById('map-container');
    if (!mapContainer) return;

    mapContainer.innerHTML = `<h3>Sightings Risk Map (Last ${timeframe} Days)</h3><div id="map"></div><p id="map-caption"><strong>Expert Analysis:</strong> This map plots each eBird wildlife sighting as a colored dot corresponding to its calculated ICAO risk level (based on frequency, mass, flocking). This allows for a direct visual assessment of where high-risk species (red dots) are located relative to the aerodrome and its critical <strong>13km radius (dashed circle)</strong>. Click on any dot for details.</p><div class="download-controls"><button id="download-csv-btn" class="btn btn-secondary">Download CSV</button><button id="download-kml-btn" class="btn btn-secondary">Download KML</button></div>`;

    if (myMap) myMap.remove(); // Remove previous map instance if exists
    myMap = L.map('map').setView([lat, lon], 9);
    myMap.createPane('markerPane').style.zIndex = 650;
    L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        attribution: 'Map data: © OpenStreetMap contributors, SRTM | Map style: © OpenTopoMap (CC-BY-SA)'
    }).addTo(myMap);

    // --- UPDATED: Create a more detailed map for risk lookup ---
    const speciesRiskDetailsMap = new Map(data.allSpecies.map(s => [s.name, {
        category: getRiskCategory(s.severity, s.likelihood),
        severity: s.severity,
        likelihood: s.likelihood,
        source: s.source // Include source (Internal DB, Wikipedia, Manual, etc.)
    }]));

    const riskColors = {
        intolerable: 'var(--risk-intolerable)',
        tolerable: 'var(--risk-tolerable)',
        acceptable: 'var(--risk-acceptable)',
        unknown: '#808080'
    };

    observations.forEach(obs => {
        const riskDetails = speciesRiskDetailsMap.get(obs.comName) || { category: 'unknown', severity: 'N/A', likelihood: 'N/A', source: 'N/A' };
        const obsDate = obs.obsDt.split(' ')[0]; // Extract date part
        const numberSeen = obs.howMany || 1; // Use howMany if available

        const jitterLat = obs.lat + (Math.random() - 0.5) * 0.002,
              jitterLng = obs.lng + (Math.random() - 0.5) * 0.002;

        L.circleMarker([jitterLat, jitterLng], {
            radius: 5,
            fillColor: riskColors[riskDetails.category] || riskColors.unknown,
            color: '#000',
            weight: 0.5,
            opacity: 1,
            fillOpacity: 0.8,
            pane: 'markerPane'
        }).addTo(myMap).bindPopup( // --- UPDATED Popup Content ---
            `<b>${obs.comName}</b><br>` +
            `Risk: ${riskDetails.category}<br>` +
            `Severity: ${riskDetails.severity}<br>` +
            `Likelihood: ${riskDetails.likelihood}<br>` +
            `Date: ${obsDate}<br>` +
            `Number: ${numberSeen}<br>` +
            `Data Source: ${riskDetails.source}` // Show where risk calculation came from
        );
    });

    L.marker([lat, lon]).addTo(myMap).bindPopup(`<b>${airportName} (ARP)</b>`).openPopup();
    L.circle([lat, lon], {
        radius: 13000, color: '#e53e3e', weight: 2, fillOpacity: 0.05, dashArray: '5, 10'
    }).addTo(myMap).bindPopup('ICAO 13km Critical Radius');
    addMapLegend(myMap); // Reuse existing legend function
}
function addMapLegend(map) { const legend = L.control({position: 'bottomright'}); legend.onAdd = function (map) { const div = L.DomUtil.create('div', 'info legend'), levels = { 'Intolerable': 'var(--risk-intolerable)', 'Tolerable': 'var(--risk-tolerable)', 'Acceptable': 'var(--risk-acceptable)' }; div.innerHTML = '<h4>Risk Level</h4>'; for (let level in levels) { div.innerHTML += `<i style="background:${levels[level]}"></i> ${level}<br>`; } div.style.backgroundColor = 'rgba(255,255,255,0.8)'; div.style.padding = '10px'; div.style.borderRadius = '5px'; return div; }; legend.addTo(map); }
function displayMethodology(data) {document.getElementById('results-wrapper').style.display = 'block';
    document.getElementById('main-content').style.display = 'none'; const container = document.getElementById('methodology-container'); if (!container) return; const findExample = (speciesName) => data.allSpecies.find(s => s.name === speciesName); const ie = data.criticalSpecies.length > 0 ? findExample(data.criticalSpecies[0]) : null, te = data.tolerableSpecies.length > 0 ? findExample(data.tolerableSpecies[0]) : null, ae = data.acceptableSpecies.length > 0 ? findExample(data.acceptableSpecies[0]) : null; let examplesHTML = `<h4>Case Examples from this Analysis:</h4><ul><li><strong style="color: var(--risk-intolerable);">Intolerable Example:</strong> ${ie ?` The <strong>${ie.name}</strong> was classified as Intolerable due to its <strong>${ie.severity} Severity</strong> and <strong>${ie.likelihood} Likelihood</strong> (Data Source: ${ie.source}).`: 'No species fell into the Intolerable risk category.'}</li><li><strong style="color: var(--risk-tolerable);">Tolerable Example:</strong> ${te ?`The <strong>${te.name}</strong> was classified as Tolerable with <strong>${te.severity} Severity</strong> and <strong>${te.likelihood} Likelihood</strong> (Data Source: ${te.source}).`: 'No species fell into the Tolerable risk category.'}</li><li><strong style="color: var(--risk-acceptable);">Acceptable Example:</strong> ${ae ?`The <strong>${ae.name}</strong> was classified as Acceptable with <strong>${ae.severity} Severity</strong> and <strong>${ae.likelihood} Likelihood</strong> (Data Source: ${ae.source}). `: 'No species fell into the Acceptable risk category.'}</li></ul>`; container.innerHTML = `<h3>Risk Assessment Methodology (ICAO Doc 9137)</h3><p>This assessment uses a dynamic, multi-source approach to align with ICAO principles (Doc 9137) while maximizing data accuracy.</p><ul><li><strong>Data Collection:</strong> Gathers recent wildlife sightings from the eBird citizen science database.</li><li><strong>Data Enrichment (NEW):</strong> Automatically queries external databases (like Wikipedia) for species-specific body mass and flocking behavior if not present in the internal curated database. This significantly enhances accuracy.</li><li><strong>Severity Assessment:</strong> Strike <strong>Severity</strong> is calculated from the species' body mass (Internal DB > Wikipedia > Estimation).</li><li><strong>Probability Assessment:</strong> Strike <strong>Probability</strong> is based on sighting frequency, and is <strong>increased for species identified with flocking behavior</strong> to account for higher risk.</li><li><strong>Risk Calculation:</strong> The enriched Probability and Severity data are plotted on the 5x5 ICAO Risk Matrix to classify each species.</li></ul>${examplesHTML}`; }
function displayRiskMatrix(data) {
    const mc = document.getElementById('matrix-container');
    if (!mc) return;

    const overrideControlsHTML = `
        <div class="override-controls">
            <div class="toggle-container has-tooltip">
                <label for="override-mode-toggle">Enable Manual Override</label>
                <label class="switch">
                    <input type="checkbox" id="override-mode-toggle">
                    <span class="slider"></span>
                </label>
                <div class="tooltip-icon">?</div>
                <div class="tooltip-text" style="width: 350px;">
                    <h4>Manual Override Mode</h4>
                    <p>When enabled, you can click on any species within the matrix to manually adjust its Severity and Likelihood ratings based on your local knowledge. These adjustments are saved locally for this airport only.</p>
                </div>
            </div>
        </div>
    `;

    const reversedLikelihood = LIKELIHOOD_LEVELS.slice().reverse();
    let matrixHTML = `<h3>ICAO Risk Assessment Matrix</h3>${overrideControlsHTML}<div class="risk-matrix-wrapper"><div class="risk-matrix-y-axis">${SEVERITY_LEVELS.slice().reverse().map(sev =>` <div>${sev}<br>Severity</div>`).join('')}</div><div class="risk-matrix">${reversedLikelihood.map(lik =>` <div class="matrix-header">${lik}<br>Likelihood</div>`).join('')}`;

    SEVERITY_LEVELS.slice().reverse().forEach((sev) => {
        reversedLikelihood.forEach((lik) => {
            const speciesInCell = data.matrixData[`${sev}-${lik}`] || [];
            const cellClass = getRiskCategory(sev, lik);
            matrixHTML += `<div class="matrix-cell ${cellClass}"><div class="matrix-cell-content">${speciesInCell.map(s => {
                const adjustedClass = s.source === 'Manually Adjusted' ? 'manually-adjusted' : '';
                return `<div class="matrix-cell-item ${adjustedClass}" title="Rating Source: ${s.source}" data-species-name="${s.name}">${s.name}</div>`;
            }).join('')}</div></div>`;
        });
    });

    matrixHTML += '</div></div>';
    mc.innerHTML = matrixHTML;

    // Add event listeners for the new override feature
    const overrideToggle = document.getElementById('override-mode-toggle');
    const matrixWrapper = document.querySelector('.risk-matrix-wrapper');

    overrideToggle.addEventListener('change', () => {
        matrixWrapper.classList.toggle('override-mode-active', overrideToggle.checked);
    });

    matrixWrapper.addEventListener('click', (event) => {
        if (overrideToggle.checked && event.target.classList.contains('matrix-cell-item')) {
            const speciesName = event.target.dataset.speciesName;
            openOverrideModal(speciesName, event);
        }
    });
}
// REPLACE your old displayTrendsChart function with this FINAL, correct version
async function displayTrendsChart(sightings, allSpeciesData, timeframe) {
    if (myTrendsChart) myTrendsChart.destroy();
    const ctx = document.getElementById('trends-chart').getContext('2d');
    const rootStyles = getComputedStyle(document.documentElement),
        ic = rootStyles.getPropertyValue('--risk-intolerable').trim(),
        tc = rootStyles.getPropertyValue('--risk-tolerable').trim(),
        ac = rootStyles.getPropertyValue('--risk-acceptable').trim();

    const speciesRiskMap = new Map(allSpeciesData.map(s => [s.name, { severity: s.severity, likelihood: s.likelihood }]));
    
    const dateLabels = [...Array(30).keys()].map(i => {
        const d = new Date();
        // Start from UTC midnight, then subtract days
        d.setUTCHours(0, 0, 0, 0);
        d.setUTCDate(d.getUTCDate() - i);
        // Format the date as YYYY-MM-DD using UTC methods
        const year = d.getUTCFullYear();
        const month = String(d.getUTCMonth() + 1).padStart(2, '0');
        const day = String(d.getUTCDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }).reverse();

    const dailyData = dateLabels.reduce((acc, label) => {
        acc[label] = { intolerable: { count: 0, species: new Map() }, tolerable: { count: 0, species: new Map() }, acceptable: { count: 0, species: new Map() } };
        return acc;
    }, {});

    sightings.forEach(s => {
    // Explicitly parse the eBird date string as UTC by adding 'Z'
    const dateObj = new Date(s.obsDt + 'Z');

    // Format the date back to a YYYY-MM-DD string using UTC methods
    const year = dateObj.getUTCFullYear();
    const month = String(dateObj.getUTCMonth() + 1).padStart(2, '0');
    const day = String(dateObj.getUTCDate()).padStart(2, '0');
    const date = `${year}-${month}-${day}`;

    // Get the number of birds seen in this observation
    const numberSeen = s.howMany || 1; // Use howMany, default to 1 if missing

    if (dailyData[date]) {
        const speciesInfo = speciesRiskMap.get(s.comName);
        if (speciesInfo) {
            const category = getRiskCategory(speciesInfo.severity, speciesInfo.likelihood);
            if (dailyData[date][category]) {
                // *** CHANGE: Increment total count by numberSeen ***
                dailyData[date][category].count += numberSeen;

                // *** CHANGE: Use Map and add species with its count ***
                const speciesMap = dailyData[date][category].species; // Access the Map
                speciesMap.set(s.comName, (speciesMap.get(s.comName) || 0) + numberSeen); // Update count in Map
            }
        }
    }
}); // End sightings.forEach

    myTrendsChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: 'Intolerable Sightings',
                data: dateLabels.map(label => ({ x: label, y: dailyData[label].intolerable.count })),
                borderColor: ic, tension: 0.1, fill: false, borderWidth: 2.5
            }, {
                label: 'Tolerable Sightings',
                data: dateLabels.map(label => ({ x: label, y: dailyData[label].tolerable.count })),
                borderColor: tc, tension: 0.1, fill: false, borderWidth: 2.5
            }, {
                label: 'Acceptable Sightings',
                data: dateLabels.map(label => ({ x: label, y: dailyData[label].acceptable.count })),
                borderColor: ac, tension: 0.1, fill: false, borderWidth: 2.5
            }]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day' }
                }
            },
            plugins: {
                annotation: { annotations: {} },
                tooltip: {
                    bodyAlign: 'left', // Helps with readability of wrapped text
                    callbacks: {
                        // PASTE THIS NEW, IMPROVED FUNCTION
// --- ENHANCED TOOLTIP FOOTER LOGIC (with counts) for eBird Data ---
                footer: function(tooltipItems) {
                    if (!tooltipItems || tooltipItems.length === 0) { return null; }
                    const item = tooltipItems[0];
                    const dateTimestamp = item.parsed.x;
                    const d = new Date(dateTimestamp);

                    // --- Generate the lookup key using LOCAL date parts ---
                    // Chart.js seems to use local time for axis/tooltips from 'YYYY-MM-DD' labels
                    const year = d.getFullYear();
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    const dateString = `${year}-${month}-${day}`;
                    // --- END LOCAL DATE KEY ---

                    // Look up the processed data for this specific date
                    const dataForDay = dailyData[dateString];
                    if (!dataForDay) {
                        // Should not happen if dateLabels cover the range, but added as safeguard
                        console.warn(`eBird Tooltip: No dailyData found for derived local date: ${dateString}`);
                        return null;
                    }

                    const datasetIndex = item.datasetIndex; // 0=Intolerable, 1=Tolerable, 2=Acceptable
                    let speciesMap; // Use Map variable
                    let title = '';
                    let categoryKey = '';

                    // Determine category based on which line was hovered
                    if (datasetIndex === 0) {
                        categoryKey = 'intolerable'; title = 'Intolerable Species Seen:';
                    } else if (datasetIndex === 1) {
                        categoryKey = 'tolerable'; title = 'Tolerable Species Seen:';
                    } else { // datasetIndex === 2
                        categoryKey = 'acceptable'; title = 'Acceptable Species Seen:';
                    }

                    // Access the Map of species for the determined category and date
                    speciesMap = dataForDay[categoryKey]?.species;

                    // Get the total count plotted for this point (sum of howMany)
                    const plottedCount = item.parsed.y;

                    // Don't show footer if the plotted count is 0 or the species map is empty/missing
                    if (plottedCount === 0 || !speciesMap || speciesMap.size === 0) {
                        return null;
                    }

                    // Convert Map entries [name, count] to an array and sort alphabetically by species name
                    const speciesArray = Array.from(speciesMap.entries()).sort((a, b) => a[0].localeCompare(b[0]));
                    let footerLines;

                    // Apply wrapping logic if more than 10 species
                    if (speciesArray.length > 10) {
                        const wrappedLines = [];
                        let currentLine = '';
                        // Loop through [species, count] pairs
                        speciesArray.forEach(([species, count]) => {
                            const speciesString = `${species} (${count})`; // Format name with count
                            if (currentLine === '') {
                                currentLine = speciesString;
                            } else if (currentLine.length + speciesString.length + 2 < 70) { // Check length with count
                                currentLine += `, ${speciesString}`;
                            } else {
                                wrappedLines.push(currentLine);
                                currentLine = speciesString;
                            }
                        });
                        wrappedLines.push(currentLine); // Add the last line
                        footerLines = wrappedLines;
                    } else {
                        // Use vertical list for 10 or fewer species
                        // Map [species, count] pairs to formatted string "- Name (Count)"
                        footerLines = speciesArray.map(([name, count]) => `- ${name} (${count})`);
                    }

                    // Add the category title (e.g., "Intolerable Species Seen:") at the beginning
                    footerLines.unshift(title);

                    // Return the formatted lines for the tooltip footer
                    return footerLines;
                }
                // --- END ENHANCED TOOLTIP FOOTER LOGIC ---
                    }
                }
            }
        }
    });

    const cc = document.getElementById('trends-caption');
    if (cc) {
        const ie = currentProcessedData.criticalSpecies.length > 0 ? `e.g., an influx of <strong>${currentProcessedData.criticalSpecies[0]}</strong>` : '';
        cc.innerHTML = `<strong>Expert Analysis:</strong> This graph shows the **external wildlife pressure** in the 30km vicinity, based on public eBird data. It is a tool for strategic analysis, not a real-time log of on-aerodrome activity.<ul><li style="margin-top: 0.5rem">Use this data to understand the environment you operate in. A spike in the <strong style="color: var(--risk-intolerable);">Intolerable (Red)</strong> line indicates heightened regional risk${ie}.</li><li style="margin-top: 0.5rem"><strong>Evaluate your WHMP</strong> by comparing this external trend to your internal aerodrome logs. If the red line spikes but your internal logs remain low, your mitigation measures are likely effective at preventing incursions.</li><li style="margin-top: 0.5rem">A sustained decrease in the red and orange lines after a mitigation action logged in your plan (vertical gray lines) can indicate the regional effectiveness of broader strategies like off-aerodrome habitat modification.</li></ul>This trend analysis is key for identifying seasonal patterns and justifying long-term, proactive wildlife management planning.`;
    }
    const imagesContainer = document.getElementById('species-images-container');
    imagesContainer.innerHTML = `<div class="loader" style="margin: 2rem auto;"></div><p style="text-align:center;">Loading species images...</p>`;
    const intolerableHTML = await createGallery('Intolerable Species', currentProcessedData.criticalSpecies, 'var(--risk-intolerable)'),
        tolerableHTML = await createGallery('Tolerable Species', currentProcessedData.tolerableSpecies, 'var(--risk-tolerable)'),
        acceptableHTML = await createGallery('Acceptable Species', currentProcessedData.acceptableSpecies, 'var(--risk-acceptable)');
    imagesContainer.innerHTML = `<h3 style="margin-top: 2rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem;">Visual Guide: All Species in Period (Last ${timeframe} Days)</h3>${intolerableHTML}${tolerableHTML}${acceptableHTML}`;
}
function displayMitigationContent(data) { const intro = document.getElementById('mitigation-intro'), flow = document.getElementById('mitigation-flow'), example = document.getElementById('mitigation-example'), framework = document.getElementById('mitigation-framework'); if (!intro || !flow || !example || !framework) return; intro.innerHTML = `<p style="margin-top:1rem; color: var(--text-light);">Effective wildlife hazard management is a continuous cycle. Mitigation actions are implemented when the risk assessment identifies an <strong>Intolerable</strong> or high-level <strong>Tolerable</strong> risk. The goal is to reduce the likelihood and/or severity of a wildlife strike to an acceptable level.</p>`; flow.innerHTML = `<h4 style="margin-top: 2rem;">ICAO Mitigation Process Flow</h4><div class="process-flow"><div class="process-step step-intolerable"><h4>1. Hazard Identification</h4><p>An Intolerable or high-Tolerable risk is identified via the Risk Matrix.</p></div><div class="process-arrow">➔</div><div class="process-step step-tolerable"><h4>2. Select Mitigation</h4><p>Choose an action based on species, behavior, and location.</p></div><div class="process-arrow">➔</div><div class="process-step step-neutral"><h4>3. Plan & Implement</h4><p>Define the task, assign an owner, and execute the action.</p></div><div class="process-arrow">➔</div><div class="process-step step-acceptable"><h4>4. Monitor & Evaluate</h4><p>Use Trend Analysis and internal logs to measure effectiveness.</p></div></div>`; const exSpecies = data.criticalSpecies.length > 0 ? data.criticalSpecies[0] : (data.tolerableSpecies.length > 0 ? data.tolerableSpecies[0] : 'a hazardous species'); example.innerHTML = `<h4 style="margin-top: 2rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem;">Case Example In Action</h4><div class="process-flow"><div class="process-step"><h4>1. Hazard ID</h4><p>The <strong>${exSpecies}</strong> is identified as an <strong>Intolerable Risk</strong>.</p></div><div class="process-arrow">➔</div><div class="process-step"><h4>2. Select Action</h4><p>An initial <strong>Active Dispersal</strong> action is chosen to address the immediate risk.</p></div><div class="process-arrow">➔</div><div class="process-step"><h4>3. Plan</h4><p>Log the action below: "Bio-acoustic dispersal of ${exSpecies}", assign to "Airside Ops".</p></div><div class="process-arrow">➔</div><div class="process-step"><h4>4. Evaluate</h4><p>Monitor the Trend Analysis chart for a decrease in the red line and confirm reduction in internal logs.</p></div></div>`; framework.innerHTML = `<h4 style="margin-top: 2rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem;">Conceptual Framework for Mitigation</h4><div class="framework-grid"><div class="framework-card" style="border-color: var(--risk-intolerable);"><h4>1. Phenomena (The Hazard)</h4><p>The presence of <strong>${exSpecies}</strong>, identified as 'Intolerable' by the ICAO Risk Matrix.</p></div><div class="framework-card" style="border-color: var(--risk-tolerable);"><h4>2. Approach (The Goal)</h4><p>To reduce the strike risk by actively deterring the species and making the habitat less attractive.</p></div><div class="framework-card" style="border-color: var(--primary-blue);"><h4>3. Methodology (The Plan)</h4><ul><li><strong>What:</strong> Implement a multi-faceted approach using both short-term dispersal and long-term habitat modification.</li><li><strong>How:</strong> Use bio-acoustic systems for immediate dispersal. Begin a program to manage grass height.</li><li><strong>Who:</strong> Airside Operations for dispersal; Groundskeeping for habitat mod.</li></ul></div><div class="framework-card" style="border-color: var(--risk-acceptable);"><h4>4. Expected Results (The Outcome)</h4><p>A measurable reduction in sightings, leading to re-classification to 'Tolerable' or 'Acceptable' on the next risk assessment.</p></div></div>`; }
function downloadFile(content, fileName, mimeType) { const a = document.createElement('a'), blob = new Blob([content], { type: mimeType }), url = URL.createObjectURL(blob); a.href = url; a.download = fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }
function downloadCSV(airportName) { if (!currentSightings || !currentProcessedData) return; const sm = new Map(currentProcessedData.allSpecies.map(s => [s.name, { category: getRiskCategory(s.severity, s.likelihood), severity: s.severity, likelihood: s.likelihood, source: s.source }])); let csv = 'Species,Risk Category,Severity,Likelihood,Data Source,Latitude,Longitude,Date,Time\n'; currentSightings.forEach(obs => { const ri = sm.get(obs.comName) || { category: 'unknown', severity: 'unknown', likelihood: 'unknown', source: 'N/A' }; const [date, time] = obs.obsDt.split(' '); csv += [`"${obs.comName}"`, ri.category, ri.severity, ri.likelihood, ri.source, obs.lat, obs.lng, date, time || ''].join(',') + '\n'; }); downloadFile(csv, `${airportName.replace(/ /g, '_')}_sightings.csv`, 'text/csv;charset=utf-8;'); }
// --- UPDATED downloadKML ---
function downloadKML(airportName) {
    if (!currentSightings || !currentProcessedData || !currentAirport) return;

    // --- UPDATED: Use the more detailed map for risk lookup ---
    const speciesRiskDetailsMap = new Map(currentProcessedData.allSpecies.map(s => [s.name, {
        category: getRiskCategory(s.severity, s.likelihood),
        severity: s.severity,
        likelihood: s.likelihood,
        source: s.source
    }]));

    const cc = createCircle(parseFloat(currentAirport.lat), parseFloat(currentAirport.lon), 13);
    const styleMap = {
        intolerable: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png', // More standard icons
        tolerable: 'http://maps.google.com/mapfiles/ms/icons/yellow-dot.png',
        acceptable: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png',
        airport: 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png' // Or an airport icon if preferred
    };

    let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
  <name>${airportName} Wildlife Sightings (Last 30 Days)</name>

  <Style id="intolerableStyle"><IconStyle><Icon><href>${styleMap.intolerable}</href></Icon></IconStyle></Style>
  <Style id="tolerableStyle"><IconStyle><Icon><href>${styleMap.tolerable}</href></Icon></IconStyle></Style>
  <Style id="acceptableStyle"><IconStyle><Icon><href>${styleMap.acceptable}</href></Icon></IconStyle></Style>
  <Style id="airportStyle"><IconStyle><scale>1.2</scale><Icon><href>${styleMap.airport}</href></Icon></IconStyle></Style>
  <Style id="radiusStyle"><LineStyle><color>ff3e3ee5</color><width>2</width></LineStyle><PolyStyle><fill>0</fill></PolyStyle></Style>

  <Placemark>
    <name>${airportName.replace(/&/g, '&amp;')} (ARP)</name>
    <styleUrl>#airportStyle</styleUrl>
    <Point><coordinates>${currentAirport.lon},${currentAirport.lat},0</coordinates></Point>
  </Placemark>

  <Placemark>
    <name>13km Critical Radius</name>
    <styleUrl>#radiusStyle</styleUrl>
    <Polygon><outerBoundaryIs><LinearRing><coordinates>${cc}</coordinates></LinearRing></outerBoundaryIs></Polygon>
  </Placemark>`;

    currentSightings.forEach(obs => {
        const riskDetails = speciesRiskDetailsMap.get(obs.comName) || { category: 'unknown', severity: 'N/A', likelihood: 'N/A', source: 'N/A' };
        const rc = riskDetails.category; // Get the risk category string
        const obsDate = obs.obsDt.split(' ')[0];
        const numberSeen = obs.howMany || 1;

        // Apply slight jitter for KML as well to avoid overlap
        const lat = parseFloat(obs.lat) + (Math.random() - 0.5) * 0.001;
        const lng = parseFloat(obs.lng) + (Math.random() - 0.5) * 0.001;

        // --- UPDATED Description with CDATA ---
        const descriptionContent = `<![CDATA[
            <b>Risk:</b> ${riskDetails.category}<br>
            <b>Severity:</b> ${riskDetails.severity}<br>
            <b>Likelihood:</b> ${riskDetails.likelihood}<br>
            <b>Number Seen:</b> ${numberSeen}<br>
            <b>Date:</b> ${obsDate}<br>
            <b>Data Source:</b> ${riskDetails.source}
        ]]>`;

        kml += `
  <Placemark>
    <name>${obs.comName.replace(/&/g, '&amp;')}</name>
    <description>${descriptionContent}</description>
    <styleUrl>#${rc}Style</styleUrl>
    <Point><coordinates>${lng},${lat},0</coordinates></Point>
  </Placemark>`;
    });

    kml += `
</Document>
</kml>`;

    downloadFile(kml, `${airportName.replace(/ /g, '_')}_sightings_last30days.kml`, 'application/vnd.google-earth.kml+xml');
}
function downloadIbisCSV() { const isMerged = mergeIbisToggle.checked; 
  // NEW: Get selected airports for IBIS
  const selectedAirports = getSelectedAirports('ibis');
  let reportsToDownload = [];
  
  if (isMerged) {
    // Include all airports that are toggled on
    Object.keys(ibisReports).forEach(icao => {
      if (selectedAirports.includes(icao)) {
        reportsToDownload = reportsToDownload.concat(ibisReports[icao].map(report => ({...report, airport: icao})));
      }
    });
  } else if (currentAirport && selectedAirports.includes(currentAirport.icao)) {
    reportsToDownload = (ibisReports[currentAirport.icao] || []).map(report => ({...report, airport: currentAirport.icao}));
  }
  
  if (reportsToDownload.length === 0) return alert('No IBIS reports to download.');
  
  const fileName = isMerged ? 'Selected_Airports_IBIS_Reports.csv' : `${currentAirport.name.replace(/ /g, '_')}_IBIS_reports.csv`;
  
  // NEW: Add Airport column to CSV
  const h = ['Airport', ...ibisFormFields.map(f => f.label), 'Struck Parts', 'Damaged Parts', 'Timestamp'].join(',');
  const r = reportsToDownload.map(rp => {
    const rd = [rp.airport, ...ibisFormFields.map(f => `"${rp[f.id] || ''}"`)];
    rd.push(`"${(rp.struckParts || []).join('; ')}"`);
    rd.push(`"${(rp.damagedParts || []).join('; ')}"`);
    rd.push(`"${rp.timestamp || ''}"`);
    return rd.join(',');
  });
  const c = h + '\n' + r.join('\n');
  downloadFile(c, fileName, 'text/csv;charset=utf-8;'); }

// ... This is after the end of the downloadKML function ...

// --- NEW FUNCTION FOR INTERNAL SIGHTINGS MAP ---
function displayInternalSightingsMap(csvData) { // PARAMETER CHANGED
    const mapContainer = document.getElementById('internal-map-container');
    if (!mapContainer || !csvData || csvData.length === 0 || !currentAirport) {
        if (mapContainer) mapContainer.style.display = 'none';
        return;
    }

    mapContainer.style.display = 'block';

    // This HTML includes the new download button IDs
    mapContainer.innerHTML = `<h3>Internal Sightings Pressure Map</h3>
        <div id="internal-map" style="width: 100%; height: 500px; border-radius: var(--radius); margin-bottom: 1rem;"></div>
        <p id="internal-map-caption"><strong>Expert Analysis:</strong> This map plots each individual sighting from your uploaded internal data based on its recorded coordinates. Pins are colored by the risk level defined in your CSV (<strong>severity</strong> and <strong>likelihood</strong>). Use this to identify internal hotspots and correlate them with the 'scene' data you provided.</p>
        <div class="download-controls">
            <button id="download-internal-csv-btn" class="btn btn-secondary">Download CSV</button>
            <button id="download-internal-kml-btn" class="btn btn-secondary">Download KML</button>
      _ </div>`;
    
    if (internalMap) internalMap.remove();

    const lat = parseFloat(currentAirport.lat);
    const lon = parseFloat(currentAirport.lon);
    
    internalMap = L.map('internal-map').setView([lat, lon], 9);
    internalMap.createPane('markerPane').style.zIndex = 650;
    L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        attribution: 'Map data: © OpenStreetMap contributors, SRTM | Map style: © OpenTopoMap (CC-BY-SA)'
    }).addTo(internalMap);

    // REMOVED: speciesRiskMap logic
    
    const riskColors = {
        intolerable: 'var(--risk-intolerable)',
        tolerable: 'var(--risk-tolerable)',
        acceptable: 'var(--risk-acceptable)',
        unknown: '#808080'
    };

    let mappedPoints = 0;
    csvData.forEach(obs => {
        // Use the parsed lat/lng from the obs object
        const obsLat = obs.lat; 
        const obsLng = obs.lng;

        // Skip if this row had invalid coordinates
        if (obsLat === null || obsLng === null) return; 

        // NEW: Calculate risk directly from the observation's properties
        const riskInfo = {
            category: getRiskCategory(obs.severity, obs.likelihood),
            source: 'Internal Data'
        };
        
        const jitterLat = obsLat + (Math.random() - 0.5) * 0.002,
            jitterLng = obsLng + (Math.random() - 0.5) * 0.002;
            
        // NEW: Updated popup content
        L.circleMarker([jitterLat, jitterLng], {
            radius: 5,
            fillColor: riskColors[riskInfo.category] || riskColors.unknown,
            color: '#000',
            weight: 0.5,
            opacity: 1,
            fillOpacity: 0.8,
            pane: 'markerPane'
        }).addTo(internalMap).bindPopup(`<b>${obs.species}</b><br>Risk: ${riskInfo.category}<br>Severity: ${obs.severity}<br>Likelihood: ${obs.likelihood}<br>Date: ${obs.date}<br>Number: ${obs.number}<br>Scene: ${obs.scene}`);
        mappedPoints++;
    });

    if (mappedPoints === 0) {
        mapContainer.innerHTML += `<p class="status-message error">No valid coordinates found in the uploaded file. Map could not be generated.</p>`;
    }

    L.marker([lat, lon]).addTo(internalMap).bindPopup(`<b>${currentAirport.name} (ARP)</b>`).openPopup();
    L.circle([lat, lon], {
        radius: 13000,
        color: '#e53e3e',
        weight: 2,
        fillOpacity: 0.05,
        dashArray: '5, 10'
    }).addTo(internalMap).bindPopup('ICAO 13km Critical Radius');
    addMapLegend(internalMap); // Reuse existing legend function
}

// --- NEW FUNCTION FOR INTERNAL CSV DOWNLOAD ---
function downloadInternalCSV(airportName) {
    if (!internalAirportData[currentAirport.icao]) return; // No longer needs currentInternalSpeciesData

    const data = internalAirportData[currentAirport.icao];
    // REMOVED: speciesMap logic

    // NEW: Updated header row
    let csv = 'Species,Risk Category,Severity,Likelihood,Date,Number,Scene,Location (Raw),Latitude,Longitude\n';
    
    data.forEach(obs => {
        // NEW: Calculate risk category directly from the observation
        const riskCategory = getRiskCategory(obs.severity, obs.likelihood);
        
        // NEW: Updated columns
        csv += [
            `"${obs.species}"`,
            riskCategory,
            obs.severity,
            obs.likelihood,
            `"${obs.date}"`,
            obs.number,
            `"${obs.scene}"`,
            `"${obs.location}"`,
            obs.lat || '',
            obs.lng || ''
        ].join(',') + '\n';
    });

    downloadFile(csv, `${airportName.replace(/ /g, '_')}_internal_sightings.csv`, 'text/csv;charset=utf-8;');
}

// --- NEW FUNCTION FOR INTERNAL KML DOWNLOAD ---
function downloadInternalKML(airportName) {
    if (!internalAirportData[currentAirport.icao] || !currentAirport) return; // No longer needs currentInternalSpeciesData

    const data = internalAirportData[currentAirport.icao];
    const cc = createCircle(parseFloat(currentAirport.lat), parseFloat(currentAirport.lon), 13);

    const styleMap = {
        intolerable: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png',
        tolerable: 'http://maps.google.com/mapfiles/ms/icons/yellow-dot.png',
        acceptable: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png',
        airport: 'http://maps.google.com/mapfiles/kml/shapes/airports.png'
    };

    let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
  <name>${airportName} Internal Wildlife Sightings</name>

  <Style id="intolerableStyle"><IconStyle><Icon><href>${styleMap.intolerable}</href></Icon></IconStyle></Style>
  <Style id="tolerableStyle"><IconStyle><Icon><href>${styleMap.tolerable}</href></Icon></IconStyle></Style>
  <Style id="acceptableStyle"><IconStyle><Icon><href>${styleMap.acceptable}</href></Icon></IconStyle></Style>
  <Style id="airportStyle"><IconStyle><scale>1.5</scale><Icon><href>${styleMap.airport}</href></Icon></IconStyle></Style>
  <Style id="radiusStyle"><LineStyle><color>ff3e3ee5</color><width>3</width></LineStyle><PolyStyle><fill>0</fill></PolyStyle></Style>

  <Placemark>
    <name>${airportName.replace(/&/g, '&')} (ARP)</name>
    <styleUrl>#airportStyle</styleUrl>
    <Point><coordinates>${currentAirport.lon},${currentAirport.lat},0</coordinates></Point>
  </Placemark>

  <Placemark>
    <name>13km Critical Radius</name>
    <styleUrl>#radiusStyle</styleUrl>
    <Polygon><outerBoundaryIs><LinearRing><coordinates>${cc}</coordinates></LinearRing></outerBoundaryIs></Polygon>
  </Placemark>`;

    data.forEach(obs => { 
        if (obs.lat === null || obs.lng === null) return; // Skip points without coords

        // NEW: Calculate risk category directly from the observation
        const rc = getRiskCategory(obs.severity, obs.likelihood) || 'unknown';
        
        // NEW: Updated description content
        const descriptionContent = `<![CDATA[
            <b>Risk:</b> ${rc}<br>
            <b>Severity:</b> ${obs.severity}<br>
            <b>Likelihood:</b> ${obs.likelihood}<br>
            <b>Number:</b> ${obs.number}<br>
            <b>Date:</b> ${obs.date}<br>
            <b>Scene:</b> ${obs.scene.replace(/&/g, '&')}
        ]]>`;

        const lat = parseFloat(obs.lat) + (Math.random() - 0.5) * 0.002;
        const lng = parseFloat(obs.lng) + (Math.random() - 0.5) * 0.002;

        kml += `
  <Placemark>
    <name>${obs.species.replace(/&/g, '&')}</name>
    <description>${descriptionContent}</description>
    <styleUrl>#${rc}Style</styleUrl>
    <Point><coordinates>${lng},${lat},0</coordinates></Point>
  </Placemark>`;
    }); 

    kml += `
</Document>
</kml>`;

    downloadFile(kml, `${airportName.replace(/ /g, '_')}_internal_sightings.kml`, 'application/vnd.google-earth.kml+xml');
}


function downloadMitigationCSV() { const isMerged = mergeMitigationToggle.checked; 
  // NEW: Get selected airports for mitigation
  const selectedAirports = getSelectedAirports('mitigation');
  let logToDownload = [];
  
  if (isMerged) {
    // Include all airports that are toggled on
    Object.keys(mitigationLog).forEach(icao => {
      if (selectedAirports.includes(icao)) {
        logToDownload = logToDownload.concat(mitigationLog[icao].map(log => ({...log, airport: icao})));
      }
    });
  } else if (currentAirport && selectedAirports.includes(currentAirport.icao)) {
    logToDownload = (mitigationLog[currentAirport.icao] || []).map(log => ({...log, airport: currentAirport.icao}));
  }
  
  if (logToDownload.length === 0) return alert('No mitigation actions to download.');
  
  const fileName = isMerged ? 'Selected_Airports_Mitigation_Log.csv' : `${currentAirport.name.replace(/ /g, '_')}_Mitigation_Log.csv`;
  
  // NEW: Add Airport column to CSV
  const h = ['Airport', 'Date', 'Action Type', 'Owner', 'Notes', 'Timestamp'].join(',');
  const r = logToDownload.map(l => [`"${l.airport}"`, `"${l.date}"`, `"${l.type}"`, `"${l.owner}"`, `"${l.notes}"`, `"${l.timestamp}"`].join(','));
  const c = h + '\n' + r.join('\n');
  downloadFile(c, fileName, 'text/csv;charset=utf-8;'); }
// PASTE THIS NEW VERSION of the addMitigationLog function
function addMitigationLog() {
    if (!currentAirport) return showStatusMessage('log-status', 'Cannot add log without a loaded airport profile.', 'error');
    const date = document.getElementById('mitigation-date').value,
        type = document.getElementById('mitigation-type').value,
        owner = document.getElementById('mitigation-owner').value,
        notes = document.getElementById('mitigation-notes').value;
    if (!date || !owner) return showStatusMessage('log-status', 'Please select a date and specify an owner.', 'error');
    const logForAirport = mitigationLog[currentAirport.icao] || [];
    
    // MODIFICATION: Added 'icao' property to the log object
    logForAirport.push({ icao: currentAirport.icao, date, type, owner, notes, timestamp: new Date().toISOString() });
    
    logForAirport.sort((a, b) => new Date(a.date) - new Date(b.date));
    mitigationLog[currentAirport.icao] = logForAirport;
    saveMitigationLogToLocal();
    refreshLocalDataView();
    updateMitigationAnnotations();
    showStatusMessage('log-status', `Log entry added successfully for ${currentAirport.icao}.`, 'demo');
    document.getElementById('mitigation-owner').value = '';
    document.getElementById('mitigation-notes').value = '';
}
// REPLACE your old renderMitigationLog function with this new version
// PASTE THIS NEW VERSION of the renderMitigationLog function
function renderMitigationLog(logData) {
    const tb = document.getElementById('log-table-body');
    if (!tb) return;
    const thead = tb.previousElementSibling;
    const isMerged = mergeMitigationToggle.checked;

    // MODIFICATION 1: Dynamically set the table header
    if (isMerged) {
        thead.rows[0].innerHTML = '<th>Airport</th><th>Date</th><th>Action Type</th><th>Owner</th><th>Notes</th><th>Effectiveness (Strikes in next 7 days)</th><th class="actions-header">Actions</th>';
    } else {
        thead.rows[0].innerHTML = '<th>Date</th><th>Action Type</th><th>Owner</th><th>Notes</th><th>Effectiveness (Strikes in next 7 days)</th><th class="actions-header">Actions</th>';
    }

    const selectedAirports = getSelectedAirports('ibis');
    const strikeData = [];
    if (mergeIbisToggle.checked) {
        Object.keys(ibisReports).forEach(icao => {
            if (selectedAirports.includes(icao)) {
                strikeData.push(...ibisReports[icao]);
            }
        });
    } else if (currentAirport && selectedAirports.includes(currentAirport.icao)) {
        strikeData.push(...(ibisReports[currentAirport.icao] || []));
    }

    const sd = 604800000; // 7 days in milliseconds
    tb.innerHTML = logData.map(e => {
        const ed = new Date(e.date).getTime();
        const sc = strikeData.filter(r => {
            if (!r.localDate) return false;
            const rd = new Date(r.localDate).getTime();
            return rd >= ed && rd <= (ed + sd);
        }).length;

        // MODIFICATION 2: Add the airport cell only if in merge mode
        const airportName = airportDatabase[e.icao]?.name || e.icao;
        const airportCell = isMerged ? `<td>${airportName}</td>` : '';

        return `<tr>
                    ${airportCell}
                    <td>${e.date}</td>
                    <td>${e.type}</td>
                    <td>${e.owner}</td>
                    <td>${e.notes}</td>
                    <td>${sc}</td>
                    <td><button class="btn btn-danger btn-delete delete-log-btn" data-timestamp="${e.timestamp}">Delete</button></td>
                </tr>`;
    }).join('');
}
function updateMitigationAnnotations() { if (!myTrendsChart) return; const isMerged = mergeMitigationToggle.checked; let annotations = {}; 
  // NEW: Only show annotations for selected airports
  const selectedAirports = getSelectedAirports('mitigation');
  if (!isMerged && currentAirport && selectedAirports.includes(currentAirport.icao)) {
    const logForAirport = mitigationLog[currentAirport.icao] || [];
    annotations = logForAirport.reduce((acc, e) => {
      acc[`line${e.date}`] = { type: 'line', xMin: e.date, xMax: e.date, borderColor: 'rgb(150, 150, 150)', borderWidth: 2, borderDash: [6, 6], label: { content: e.type.split(' ')[0].replace('(',''), enabled: true, position: 'start', backgroundColor: 'rgba(100,100,100,0.7)', color: 'white', font: { size: 10 } } };
      return acc;
    }, {});
  }
  myTrendsChart.options.plugins.annotation.annotations = annotations;
  myTrendsChart.update(); }
function submitIbisReport() { if (!currentAirport) return showStatusMessage('ibis-status', 'Cannot submit report without a loaded airport profile.', 'error'); const report = {}; let isValid = true; ibisFormFields.forEach(f => { const el = document.getElementById(`ibis-${f.id}`); if (el) { let v = el.value; if (f.id === 'wildlifeSpecies' && v === 'Other') { const o = document.getElementById('ibis-wildlifeSpecies-other'); v = o ? o.value : ''; } report[f.id] = v; if (f.required && !v) { if(el.tagName==='SELECT' && v==='Other') { const o = document.getElementById('ibis-wildlifeSpecies-other'); if (o && !o.value) { o.style.borderColor='red'; isValid=false; } else if (o) { o.style.borderColor='var(--border-color)'; } } else { el.style.borderColor='red'; isValid=false; } } else { el.style.borderColor='var(--border-color)'; } } }); report.struckParts = partFields.filter(p => document.getElementById(`ibis-struck-${p.id}`).checked).map(p => p.label); report.damagedParts = partFields.filter(p => document.getElementById(`ibis-damaged-${p.id}`).checked).map(p => p.label); if (!isValid) return showStatusMessage('ibis-status', 'Please fill in all required fields (marked in red).', 'error'); const reportsForAirport = ibisReports[currentAirport.icao] || []; reportsForAirport.push({ ...report, timestamp: new Date().toISOString() }); ibisReports[currentAirport.icao] = reportsForAirport; saveIbisReportsToLocal(); refreshLocalDataView(); showStatusMessage('ibis-status', `IBIS report submitted successfully for ${currentAirport.icao}.`, 'demo'); document.getElementById('ibis-form-grid').querySelectorAll('input, select').forEach(el => { if (el.type !== 'checkbox') el.value = ''; }); document.getElementById('ibis-form-grid').querySelectorAll('input[type="checkbox"]').forEach(el => el.checked = false); const oi = document.getElementById('ibis-wildlifeSpecies-other'); if(oi) oi.style.display='none'; }
function generateIbisForm() { const c = document.getElementById('ibis-form-grid'); let h = ''; ibisFormFields.forEach(f => { h += `<div class="input-field" id="field-container-${f.id}"><label for="ibis-${f.id}">${f.label}${f.required ? ' *' : ''}</label>`; if (f.type === 'select') { h += `<select id="ibis-${f.id}"><option value="">--Please choose an option--</option>${f.options.map(o =>` <option value="${o}">${o}</option>`).join('')}</select>`; } else if (f.type === 'dynamic-select') { h += `<select id="ibis-${f.id}"><option value="">--Generate a risk profile first--</option></select>`; } else { h += `<input type="${f.type}" id="ibis-${f.id}" placeholder="${f.placeholder || ''}">`; } h += `</div>`; }); c.innerHTML = h; const ph = (t) => partFields.map(p => `<div class="checkbox-group"><label for="ibis-${t}-${p.id}"><input type="checkbox" id="ibis-${t}-${p.id}" value="${p.label}"><span>${p.label}</span></label></div>`).join(''); c.innerHTML += `<div class="form-section"><h4>Parts Struck</h4>${ph('struck')}</div><div class="form-section"><h4>Parts Damaged</h4>${ph('damaged')}</div>`; }
function updateIbisSpeciesDropdown(allSpecies) { const sn = [...new Set(allSpecies.map(s => s.name))].sort(), se = document.getElementById('ibis-wildlifeSpecies'); if (!se) return; se.innerHTML = `<option value="">--Please choose a species--</option>${sn.map(n =>` <option value="${n}">${n}</option>`).join('')}<option value="Other">Other...</option>`; se.addEventListener('change', (e) => { let oi = document.getElementById('ibis-wildlifeSpecies-other'); if (e.target.value === 'Other') { if (!oi) { const c = document.getElementById('field-container-wildlifeSpecies'); oi = document.createElement('input'); oi.type = 'text'; oi.id = 'ibis-wildlifeSpecies-other'; oi.placeholder = 'Enter species name'; oi.style.marginTop = '0.5rem'; c.appendChild(oi); } oi.style.display = 'block'; } else { if (oi) { oi.style.display = 'none'; } } }); }
function populateIbisFilterOptions(sourceData) { const ss = new Set(sourceData.map(r => r.wildlifeSpecies)), ps = new Set(sourceData.map(r => r.flightPhase)); const sf = document.getElementById('filter-species'), pf = document.getElementById('filter-phase'); sf.innerHTML = '<option value="">All Species</option>' + [...ss].sort().map(s => `<option value="${s}">${s}</option>`).join(''); pf.innerHTML = '<option value="">All Phases</option>' + [...ps].sort().map(p => `<option value="${p}">${p}</option>`).join(''); }
function applyIbisFilters() { const isMerged = mergeIbisToggle.checked; 
  // NEW: Get data from selected airports only
  const selectedAirports = getSelectedAirports('ibis');
  let sourceData = [];
  if (isMerged) {
    Object.keys(ibisReports).forEach(icao => {
      if (selectedAirports.includes(icao)) {
        sourceData.push(...ibisReports[icao]);
      }
    });
  } else if (currentAirport && selectedAirports.includes(currentAirport.icao)) {
    sourceData = ibisReports[currentAirport.icao] || [];
  }
  
  const sd = document.getElementById('filter-start-date').value, ed = document.getElementById('filter-end-date').value, s = document.getElementById('filter-species').value, p = document.getElementById('filter-phase').value; const fr = sourceData.filter(r => { let pass = true; if (sd && r.localDate < sd) pass = false; if (ed && r.localDate > ed) pass = false; if (s && r.wildlifeSpecies !== s) pass = false; if (p && r.flightPhase !== p) pass = false; return pass; }); updateIbisAnalysisCharts(fr); document.getElementById('ibis-analysis-subtitle').textContent = `Showing ${fr.length} of ${sourceData.length} total reports.`; }
function resetIbisFilters() { document.getElementById('filter-start-date').value = ''; document.getElementById('filter-end-date').value = ''; document.getElementById('filter-species').value = ''; document.getElementById('filter-phase').value = ''; refreshLocalDataView(); }

// NEW: Function to get selected airports for a specific tab
function getSelectedAirports(tabType) {
  const toggles = document.querySelectorAll(`#${tabType}-airport-toggles input[type="checkbox"]`);
  const selected = [];
  toggles.forEach(toggle => {
    if (toggle.checked) {
      selected.push(toggle.value);
    }
  });
  return selected;
}

// NEW: Function to update airport toggle UI
function updateAirportToggles() {
  const ibisTogglesContainer = document.getElementById('ibis-airport-toggles');
  const mitigationTogglesContainer = document.getElementById('mitigation-airport-toggles');
  
  if (!ibisTogglesContainer || !mitigationTogglesContainer) return;
  
  // Get all airports with data
  const allAirports = [...new Set([...Object.keys(ibisReports), ...Object.keys(mitigationLog)])];
  
  // Create toggle UI for IBIS tab
  ibisTogglesContainer.innerHTML = allAirports.map(icao => {
    const airportName = airportDatabase[icao] ? airportDatabase[icao].name : icao;
    const isChecked = airportToggleState.ibis[icao] !== false; // Default to true if not set
    return `
      <div class="airport-toggle-item">
        <input type="checkbox" id="ibis-toggle-${icao}" value="${icao}" ${isChecked ? 'checked' : ''}>
        <label for="ibis-toggle-${icao}">${airportName} (${icao})</label>
      </div>
    `;
  }).join('');
  
  // Create toggle UI for Mitigation tab
  mitigationTogglesContainer.innerHTML = allAirports.map(icao => {
    const airportName = airportDatabase[icao] ? airportDatabase[icao].name : icao;
    const isChecked = airportToggleState.mitigation[icao] !== false; // Default to true if not set
    return `
      <div class="airport-toggle-item">
        <input type="checkbox" id="mitigation-toggle-${icao}" value="${icao}" ${isChecked ? 'checked' : ''}>
        <label for="mitigation-toggle-${icao}">${airportName} (${icao})</label>
      </div>
    `;
  });
  
  // Add event listeners to toggles
  document.querySelectorAll('#ibis-airport-toggles input[type="checkbox"]').forEach(toggle => {
    toggle.addEventListener('change', (e) => {
      const icao = e.target.value;
      airportToggleState.ibis[icao] = e.target.checked;
      saveToggleStateToLocal();
      refreshLocalDataView();
    });
  });
  
  document.querySelectorAll('#mitigation-airport-toggles input[type="checkbox"]').forEach(toggle => {
    toggle.addEventListener('change', (e) => {
      const icao = e.target.value;
      airportToggleState.mitigation[icao] = e.target.checked;
      saveToggleStateToLocal();
      refreshLocalDataView();
    });
  });
}

function refreshLocalDataView() { 
    // NEW: Update airport toggles first
    updateAirportToggles();

    const isMergedIbis = mergeIbisToggle.checked;
    const isMergedMitigation = mergeMitigationToggle.checked;

    // NEW: Get data from selected airports only
    const selectedIbisAirports = getSelectedAirports('ibis');
    const selectedMitigationAirports = getSelectedAirports('mitigation');

    let ibisData = [];
    if (isMergedIbis) {
        Object.keys(ibisReports).forEach(icao => {
            if (selectedIbisAirports.includes(icao)) {
                ibisData.push(...ibisReports[icao]);
            }
        });
    } else if (currentAirport && selectedIbisAirports.includes(currentAirport.icao)) {
        ibisData = ibisReports[currentAirport.icao] || [];
    }

    let mitigationData = [];
    if (isMergedMitigation) {
        Object.keys(mitigationLog).forEach(icao => {
            if (selectedMitigationAirports.includes(icao)) {
                mitigationData.push(...mitigationLog[icao]);
            }
        });
    } else if (currentAirport && selectedMitigationAirports.includes(currentAirport.icao)) {
        mitigationData = mitigationLog[currentAirport.icao] || [];
    }

    updateIbisAnalysisCharts(ibisData);
    populateIbisFilterOptions(ibisData);
    renderMitigationLog(mitigationData);
    updateMitigationAnnotations();
    updateIbisDashboardCard(ibisData);
    updateMitigationDashboardCard(mitigationData);

    // --- THIS IS THE UPDATED LOGIC FOR FEATURE REQUEST #2 ---
    const ibisSubtitle = document.getElementById('ibis-analysis-subtitle');
    if (selectedIbisAirports.length > 0) {
        // Get the full names of the selected airports
        const airportNames = selectedIbisAirports.map(icao => {
            return airportDatabase[icao] ? airportDatabase[icao].name : icao;
        }).join(', ');

        // Create the new, descriptive message
        ibisSubtitle.textContent = `Visualizing reports from: ${airportNames}.`;
    } else {
        // Handle the case where no airports are selected
        ibisSubtitle.textContent = 'No airports are selected for analysis. Please choose from the list above.';
    }
}
// PASTE THESE TWO NEW FUNCTIONS

function updateIbisDashboardCard(ibisData) {
    const cardContainer = document.getElementById('ibis-dashboard-card');
    const selectedAirports = getSelectedAirports('ibis');

    if (selectedAirports.length === 0) {
        cardContainer.innerHTML = '';
return;
    }

    const totalStrikes = ibisData.length;
    const totalAirports = selectedAirports.length;
    const airportNames = selectedAirports.map(icao => airportDatabase[icao]?.name || icao).join(', ');

    const cardHTML = `
        <div class="local-data-dashboard">
            <div class="stat-card neutral"><div class="stat-value">${totalStrikes}</div><div class="stat-label">Total Strikes Reported</div></div>
            <div class="stat-card neutral"><div class="stat-value">${totalAirports}</div><div class="stat-label">Airport(s) in View</div></div>
            <div class="airport-list">
                <strong>Airport(s):</strong>
                <div class="content">${selectedAirports.map(icao => `<span class="airport-tag">${airportDatabase[icao]?.name || icao}</span>`).join('')}</div>
            </div>
        </div>
    `;
    cardContainer.innerHTML = cardHTML;
}

function updateMitigationDashboardCard(mitigationData) {
    const cardContainer = document.getElementById('mitigation-dashboard-card');
    const selectedAirports = getSelectedAirports('mitigation');

    if (selectedAirports.length === 0) {
        cardContainer.innerHTML = '';
return;
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const futureActions = mitigationData.filter(log => new Date(log.date) >= today);
    const completedActions = mitigationData.length - futureActions.length;

    let upcomingAirportIcao = null;
    if (futureActions.length > 0) {
        // Sort to find the soonest action
        futureActions.sort((a, b) => new Date(a.date) - new Date(b.date));
        upcomingAirportIcao = futureActions[0].icao;
    }

    const cardHTML = `
        <div class="local-data-dashboard">
            <div class="stat-card neutral"><div class="stat-value">${mitigationData.length}</div><div class="stat-label">Total Actions Logged</div></div>
            <div class="stat-card acceptable"><div class="stat-value">${completedActions}</div><div class="stat-label">Completed Actions</div></div>
            <div class="stat-card tolerable"><div class="stat-value">${futureActions.length}</div><div class="stat-label">Planned Actions</div></div>
            <div class="airport-list">
                <strong>Airport(s) with Logs:</strong>
                <div class="content">
                    ${selectedAirports.map(icao => {
                        const isUpcoming = icao === upcomingAirportIcao;
                        return `<span class="airport-tag ${isUpcoming ? 'airport-tag-upcoming' : ''}" title="${isUpcoming ? 'Next Upcoming Action' : ''}">${airportDatabase[icao]?.name || icao}</span>`;
                    }).join('')}
                </div>
            </div>
        </div>
    `;
    cardContainer.innerHTML = cardHTML;
}
function updateIbisAnalysisCharts(reports) { if (reports.length === 0) { return generateEmptyCharts(true); } generateEmptyCharts(false); const chartConfigs = [ { id: 'ibis-strikes-by-month-chart', type: 'bar', title: 'Strikes by Month & Year', dataFn: getStrikesByMonthAndYearData }, { id: 'ibis-phase-chart', type: 'doughnut', title: 'Strikes by Phase of Flight', dataKey: 'flightPhase' }, { id: 'ibis-light-conditions-chart', type: 'doughnut', title: 'Strikes by Light Conditions', dataKey: 'lightConditions' }, { id: 'ibis-species-chart', type: 'bar', title: 'Top 5 Struck Species', dataKey: 'wildlifeSpecies' }, { id: 'ibis-parts-struck-chart', type: 'bar', title: 'Top 5 Parts Struck', dataKey: 'struckParts', isArray: true }, { id: 'ibis-parts-damaged-chart', type: 'bar', title: 'Top 5 Parts Damaged', dataKey: 'damagedParts', isArray: true }, ]; const bgColors = ['#1a365d', '#2d3748', '#4a5568', '#718096', '#a0aec0', '#cbd5e0']; chartConfigs.forEach(cfg => { let chartData, options; if (cfg.dataFn) { const result = cfg.dataFn(reports); chartData = result.chartData; options = result.options; } else { const counts = reports.reduce((acc, r) => { const key = r[cfg.dataKey]; if (cfg.isArray && Array.isArray(key)) { key.forEach(item => { acc[item] = (acc[item] || 0) + 1; }); } else if (key) { acc[key] = (acc[key] || 0) + 1; } return acc; }, {}); const sortedData = Object.entries(counts).sort(([, a], [, b]) => b - a).slice(0, 5); chartData = { datasets: [{ label: cfg.title, data: sortedData.map(([, value]) => value), backgroundColor: bgColors }], labels: sortedData.map(([key]) => key) }; options = { plugins: { legend: { position: cfg.type === 'doughnut' ? 'top' : 'none' }, title: { display: true, text: cfg.title } } }; } const ctx = document.getElementById(cfg.id); if (!ctx) return; if (ibisCharts[cfg.id]) ibisCharts[cfg.id].destroy(); ibisCharts[cfg.id] = new Chart(ctx.getContext('2d'), { type: cfg.type, data: chartData, options: { responsive: true, maintainAspectRatio: false, ...options } }); }); }
function getStrikesByMonthAndYearData(reports) { const counts = reports.reduce((acc, r) => { if (r.localDate) { try { const date = new Date(r.localDate); if (isNaN(date.getTime())) return acc; const key = `${date.getFullYear()}-${String(date.getMonth()).padStart(2, '0')}`; acc[key] = (acc[key] || 0) + 1; } catch (e) { /* ignore */ } } return acc; }, {}); const sortedKeys = Object.keys(counts).sort(); const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; const labels = sortedKeys.map(key => { const [year, month] = key.split('-'); return `${monthNames[parseInt(month, 10)]} '${year.substring(2)}`; }); const data = sortedKeys.map(key => counts[key]); const chartData = { labels: labels, datasets: [{ label: 'Number of Strikes', data: data, backgroundColor: 'var(--secondary-blue)' }] }; const options = { plugins: { legend: { display: false }, title: { display: true, text: 'Total Strikes by Month & Year' } }, scales: { x: { ticks: { autoSkip: true, maxRotation: 45, minRotation: 0 } } } }; return { chartData, options }; }
function generateEmptyCharts(showMessages = false) { ['ibis-strikes-by-month-chart', 'ibis-phase-chart', 'ibis-light-conditions-chart', 'ibis-species-chart', 'ibis-parts-struck-chart', 'ibis-parts-damaged-chart'].forEach(id => { const canvas = document.getElementById(id); if (!canvas) return; const ctx = canvas.getContext('2d'); if (ibisCharts[id]) ibisCharts[id].destroy(); if (showMessages) { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.font = "16px 'Poppins'"; ctx.fillStyle = 'grey'; ctx.textAlign = 'center'; ctx.fillText('Submit IBIS reports to see data here.', canvas.width / 2, canvas.height / 2); } }); }
async function getWikipediaImage(speciesName) { const placeholderUrl = `https://placehold.co/150x100/f0f4f8/2d3748?text=${speciesName.replace(/ /g, '%0A')}`; const defaultReturn = { imageUrl: placeholderUrl, pageUrl: '#' }; try { const searchUrl = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(speciesName)}&format=json&origin=*`; const searchResponse = await fetch(searchUrl); const searchData = await searchResponse.json(); if (!searchData.query || searchData.query.search.length === 0) { return defaultReturn; } const bestMatchTitle = searchData.query.search[0].title; const pageUrl = `https://en.wikipedia.org/wiki/${encodeURIComponent(bestMatchTitle.replace(/ /g, '_'))}`; const imageUrlApi = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(bestMatchTitle)}&prop=pageimages&format=json&pithumbsize=150&origin=*`; const imageResponse = await fetch(imageUrlApi); const imageData = await imageResponse.json(); const page = Object.values(imageData.query.pages)[0]; const imageUrl = (page.thumbnail && page.thumbnail.source) ? page.thumbnail.source : placeholderUrl; return { imageUrl, pageUrl }; } catch (error) { console.error(`Could not fetch image for ${speciesName}:`, error); return defaultReturn; } }
const createGallery = async (title, speciesArray, color) => { if (!speciesArray || speciesArray.length === 0) return ''; let galleryHTML = `<h4 style="color: ${color}; margin-bottom: 1rem;">${title}</h4><div class="species-gallery">`; const imagePromises = speciesArray.map(async (name) => { const { imageUrl, pageUrl } = await getWikipediaImage(name); return `<a href="${pageUrl}" target="_blank" title="Learn more about ${name} on Wikipedia"><div class="species-image-card"><img src="${imageUrl}" alt="${name}" onerror="this.onerror=null;this.src='https://placehold.co/150x100/f0f4f8/2d3748?text=Image+Not+Found';"><div class="species-image-caption">${name}</div></div></a>`; }); const imageCardsHTML = await Promise.all(imagePromises); galleryHTML += imageCardsHTML.join(''); galleryHTML += '</div>'; return galleryHTML; };
function getDistance(lat1, lon1, lat2, lon2) { const R = 6371, dLat = (lat2 - lat1) * Math.PI / 180, dLon = (lon2 - lon1) * Math.PI / 180; const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c; }
function getSeverityByMass(mass) { if (mass > 4000) return 'Very High'; if (mass > 1200) return 'High'; if (mass > 200) return 'Moderate'; if (mass > 50) return 'Low'; return 'Very Low'; }
function estimateSeverityByName(name) { const vh = ['Vulture', 'Pelican', 'Crane', 'Bustard', 'Swan', 'Goose'], h = ['Stork', 'Eagle', 'Cormorant', 'Heron'], m = ['Gull', 'Ibis', 'Kite', 'Falcon', 'Duck', 'Crow', 'Raven'], l = ['Pigeon', 'Dove', 'Harrier', 'Kestrel']; if (vh.some(kw => name.includes(kw))) return { risk: 'Very High', estimated: true }; if (h.some(kw => name.includes(kw))) return { risk: 'High', estimated: true }; if (m.some(kw => name.includes(kw))) return { risk: 'Moderate', estimated: true }; if (l.some(kw => name.includes(kw))) return { risk: 'Low', estimated: true }; return { risk: 'Very Low', estimated: true }; }
function getRiskCategory(severity, likelihood) { const sevIdx = SEVERITY_LEVELS.indexOf(severity), likIdx = LIKELIHOOD_LEVELS.indexOf(likelihood); if (sevIdx===-1||likIdx===-1) return 'unknown'; return riskColorMap[sevIdx][likIdx]; }
function createCircle(lat, lon, radiusKm) {
  const R = 6371; // Earth's radius in km
  const d = radiusKm / R; // Angular distance in radians
  const latRad = lat * Math.PI / 180;
  const lonRad = lon * Math.PI / 180;
  
  let coords = '';
  const points = 36; // Number of points for smooth circle
  
  for (let i = 0; i <= points; i++) {
    const bearing = i * (360 / points) * Math.PI / 180;
    
    const circleLat = Math.asin(
      Math.sin(latRad) * Math.cos(d) + 
      Math.cos(latRad) * Math.sin(d) * Math.cos(bearing)
    );
    
    const circleLon = lonRad + Math.atan2(
      Math.sin(bearing) * Math.sin(d) * Math.cos(latRad),
      Math.cos(d) - Math.sin(latRad) * Math.sin(circleLat)
    );
    
    const circleLatDeg = circleLat * 180 / Math.PI;
    const circleLonDeg = circleLon * 180 / Math.PI;
    
    coords += `${circleLonDeg},${circleLatDeg},0 `;
  }
  
  return coords.trim();
}
function openTab(tabName) { document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active')); document.querySelectorAll('.tab-link').forEach(l => l.classList.remove('active')); document.getElementById(tabName).classList.add('active'); document.querySelector(`.tab-link[data-tab="${tabName}"]`).classList.add('active'); }
function resetToHome() { 
    // NEW: Improved reset function to fix blank page issue
    document.getElementById('results-wrapper').style.display = 'none'; 
    document.getElementById('main-content').style.display = 'block'; 
    document.getElementById('icao-code').value = ''; 
    document.getElementById('icao-code').focus(); 
    statusContainer.innerHTML = ''; 
    openTab('dashboard'); 
    currentAirport = null; 
    currentSightings = []; 
    currentProcessedData = null;

    // This new code clears the airport headers
    document.getElementById('trends-airport-display').textContent = '';
    document.getElementById('ibis-airport-display').textContent = '';
    document.getElementById('mitigation-airport-display').textContent = '';

    // Clear any existing charts and maps
    if (myMap) { 
        myMap.remove(); 
        myMap = null; 
    }
    if (myTrendsChart) { 
        myTrendsChart.destroy(); 
        myTrendsChart = null; 
    }
    Object.keys(ibisCharts).forEach(id => {
        if (ibisCharts[id]) {
            ibisCharts[id].destroy();
        }
    });
    ibisCharts = {};
// NEW: Clear internal trends chart on reset
if (internalTrendsChart) {
    internalTrendsChart.destroy();
    internalTrendsChart = null;
}
const internalTrendsContainer = document.getElementById('internal-trends-container');
if (internalTrendsContainer) internalTrendsContainer.style.display = 'none';
// NEW: Clear internal map and data on reset
currentInternalSpeciesData = null;
if (internalMap) {
    internalMap.remove();
    internalMap = null;
}
const internalMapContainer = document.getElementById('internal-map-container');
if (internalMapContainer) {
    internalMapContainer.innerHTML = '';
    internalMapContainer.style.display = 'none';
}
}
// --- NEW FUNCTIONS FOR MANUAL OVERRIDE ---
function openOverrideModal(speciesName, event) {
    const modal = document.getElementById('override-modal');
    const title = document.getElementById('override-modal-title');
    const severitySelect = document.getElementById('override-severity');
    const likelihoodSelect = document.getElementById('override-likelihood');
    const saveBtn = document.getElementById('override-modal-save');
    const cancelBtn = document.getElementById('override-modal-cancel');
    const resetBtn = document.getElementById('override-modal-reset');

    const speciesData = currentProcessedData.allSpecies.find(s => s.name === speciesName);
    if (!speciesData) return;

    title.textContent = `Override Risk for: ${speciesName}`;

    severitySelect.innerHTML = SEVERITY_LEVELS.map(level => `<option value="${level}" ${level === speciesData.severity ? 'selected' : ''}>${level}</option>`).join('');
    likelihoodSelect.innerHTML = LIKELIHOOD_LEVELS.map(level => `<option value="${level}" ${level === speciesData.likelihood ? 'selected' : ''}>${level}</option>`).join('');

    const handleSave = async () => {
        // Save the override
        const airportOverrides = riskOverrides[currentAirport.icao] || {};
        airportOverrides[speciesName] = {
            severity: severitySelect.value,
            likelihood: likelihoodSelect.value
        };
        riskOverrides[currentAirport.icao] = airportOverrides;
        saveOverridesToLocal();
        
        // Close modal
        hideOverrideModal();
        
        // Re-process the data
        currentProcessedData = await processBirdData(currentSightings, currentAirport);
        
        // Update the dashboard (matrix and stats)
        displayDashboard(currentProcessedData, currentAirport, document.getElementById('timeframe').value);
        displayMethodology(currentProcessedData);
        
        // Redraw the map with updated data
        setTimeout(() => {
            displaySightingsMap(currentSightings, parseFloat(currentAirport.lat), parseFloat(currentAirport.lon), currentAirport.name, currentProcessedData, document.getElementById('timeframe').value);
        }, 100);
        
        // Update the trend chart with new risk classifications
        await displayTrendsChart(currentSightings, currentProcessedData.allSpecies, document.getElementById('timeframe').value);
    };

    const handleReset = async () => {
        if (riskOverrides[currentAirport.icao] && riskOverrides[currentAirport.icao][speciesName]) {
            // Remove the override
            delete riskOverrides[currentAirport.icao][speciesName];
            saveOverridesToLocal();
            
            // Close modal
            hideOverrideModal();
            
            // Re-process the data
            currentProcessedData = await processBirdData(currentSightings, currentAirport);
            
            // Update the dashboard (matrix and stats)
            displayDashboard(currentProcessedData, currentAirport, document.getElementById('timeframe').value);
            displayMethodology(currentProcessedData);
            
            // Redraw the map with updated data
            setTimeout(() => {
                displaySightingsMap(currentSightings, parseFloat(currentAirport.lat), parseFloat(currentAirport.lon), currentAirport.name, currentProcessedData, document.getElementById('timeframe').value);
            }, 100);
            
            // Update the trend chart with new risk classifications
            await displayTrendsChart(currentSightings, currentProcessedData.allSpecies, document.getElementById('timeframe').value);
        } else {
            hideOverrideModal();
        }
    };

    saveBtn.onclick = handleSave;
    resetBtn.onclick = handleReset;
    cancelBtn.onclick = hideOverrideModal;

const modalContent = modal.querySelector('.modal-content');

// Make modal temporarily visible but hidden to measure it
modal.style.visibility = 'hidden';
modal.style.display = 'flex';

if (event) {
    const modalWidth = modalContent.offsetWidth;
    const modalHeight = modalContent.offsetHeight;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const padding = 10; // 10px padding from cursor and screen edge

    // Calculate Top position
    let topPos = event.clientY + padding;
    if (topPos + modalHeight + padding > vh) {
        // If it goes off-bottom, position it above the cursor
        topPos = event.clientY - modalHeight - padding;
    }
    // Ensure it doesn't go off-top
    topPos = Math.max(padding, topPos); 

    // Calculate Left position
    let leftPos = event.clientX + padding;
    if (leftPos + modalWidth + padding > vw) {
        // If it goes off-right, position it left of the cursor
        leftPos = event.clientX - modalWidth - padding;
    }
    // Ensure it doesn't go off-left
    leftPos = Math.max(padding, leftPos);

    modalContent.style.top = `${topPos}px`;
    modalContent.style.left = `${leftPos}px`;
    modalContent.style.transform = ''; // Clear any centering transforms
} else {
    // Fallback to center if event is missing
    modalContent.style.top = '50%';
    modalContent.style.left = '50%';
    modalContent.style.transform = 'translate(-50%, -50%)';
}

// Make modal visible at its new position
modal.style.visibility = 'visible';
    
}

function hideOverrideModal() {
    document.getElementById('override-modal').style.display = 'none';
}
function showStatusMessage(elementId, message, type) { const el = document.getElementById(elementId); if(el) { el.innerHTML = `<p class="status-message ${type}">${message}</p>`; setTimeout(() => { el.innerHTML = ''; }, 5000); } }
// NEW: Helper function to compare two risk levels
function isRiskHigher(newRisk, currentRisk) {
    const sevIndexNew = SEVERITY_LEVELS.indexOf(newRisk.severity);
    const likIndexNew = LIKELIHOOD_LEVELS.indexOf(newRisk.likelihood);
    const sevIndexCurr = SEVERITY_LEVELS.indexOf(currentRisk.severity);
    const likIndexCurr = LIKELIHOOD_LEVELS.indexOf(currentRisk.likelihood);

    const catNew = getRiskCategory(newRisk.severity, newRisk.likelihood);
    const catCurr = getRiskCategory(currentRisk.severity, currentRisk.likelihood);
    const catOrder = { 'intolerable': 3, 'tolerable': 2, 'acceptable': 1, 'unknown': 0 };

    if (catOrder[catNew] > catOrder[catCurr]) return true;
    if (catOrder[catNew] < catOrder[catCurr]) return false;

    // If risk categories are equal, higher severity wins
    if (sevIndexNew > sevIndexCurr) return true;
    if (sevIndexNew < sevIndexCurr) return false;

    // If severity is also equal, higher likelihood wins
    return likIndexNew > likIndexCurr;
}

// --- UPDATED handleCSVUpload ---
function handleCSVUpload() {
    if (!currentAirport) {
        showStatusMessage('csv-status', 'Please generate an airport profile first.', 'error');
        return;
    }
    const fileInput = document.getElementById('csv-upload');
    fileInput.addEventListener('change', () => { // Keep filename display logic
        if (fileInput.files.length > 0) {
            showStatusMessage('csv-status', `Selected file: ${fileInput.files[0].name}`, 'demo');
        } else {
             showStatusMessage('csv-status', 'File selection cancelled.', 'demo');
        }
    });
    const file = fileInput.files[0];
    if (!file) {
        showStatusMessage('csv-status', 'Please select a .csv file to upload.', 'error');
        return;
    }

    showStatusMessage('csv-status', 'Parsing CSV file...', 'demo');

    Papa.parse(file, {
        header: true,
        transformHeader: h => h.trim().toLowerCase(),
        skipEmptyLines: true,
        complete: async (results) => {
            // --- UPDATED Header Check ---
            // Mandatory headers for matrix/trends
            const mandatoryHeaders = ['date', 'species', 'number', 'scene', 'severity', 'likelihood'];
            // Location is optional for the map
            const allExpectedHeaders = [...mandatoryHeaders, 'location'];
            const headers = results.meta.fields;

            const missingMandatoryHeaders = mandatoryHeaders.filter(h => !headers.includes(h));

            if (missingMandatoryHeaders.length > 0) {
                showStatusMessage('csv-status', `Error: CSV file is missing mandatory headers: ${missingMandatoryHeaders.join(', ')}. File cannot be processed.`, 'error');
                return;
            }
            const hasLocationHeader = headers.includes('location');

            // --- UPDATED Row Processing & Validation ---
            let invalidLocations = 0;
            let invalidSeverity = 0;
            let invalidLikelihood = 0;
            let missingMandatoryFields = 0;
            let rowsWithValidLocation = 0; // Counter for map generation check
            const processedData = []; // Store only valid rows

            results.data.forEach((row, index) => {
                let isValidRow = true;
                const record = {};

                // Check mandatory fields
                mandatoryHeaders.forEach(header => {
                    const value = (row[header] || "").trim();
                    if (!value) {
                         console.warn(`Row ${index + 2}: Missing mandatory value for '${header}'`);
                         isValidRow = false;
                    }
                    record[header] = value; // Assign trimmed value or empty string
                });

                if (!isValidRow) {
                    missingMandatoryFields++;
                    return; // Skip this row entirely if mandatory fields are missing
                }

                // Process Location (Optional)
                let lat = null, lng = null;
                const locationString = (row.location || "").trim();
                record.location = locationString; // Store raw location string
                if (locationString) {
                    const coords = locationString.split(',');
                    const parsedLat = parseFloat(coords[0]);
                    const parsedLng = parseFloat(coords[1]);
                    if (!isNaN(parsedLat) && !isNaN(parsedLng)) {
                        lat = parsedLat;
                        lng = parsedLng;
                        rowsWithValidLocation++; // Increment if valid coordinates found
                    } else {
                        invalidLocations++; // Count as invalid format if present but not parseable
                    }
                } // No else needed, lat/lng remain null if location is missing/empty

                record.lat = lat;
                record.lng = lng;

                // Validate Severity
                if (!SEVERITY_LEVELS.includes(record.severity)) {
                    invalidSeverity++;
                    record.severity = "Very Low"; // Default
                }
                // Validate Likelihood
                if (!LIKELIHOOD_LEVELS.includes(record.likelihood)) {
                    invalidLikelihood++;
                     record.likelihood = "Very Low"; // Default
                }

                // Convert number (default to 1 if invalid/missing)
                record.number = parseInt(record.number, 10) || 1;

                processedData.push(record); // Add the validated record
            }); // End forEach row

            internalAirportData[currentAirport.icao] = processedData;
            saveInternalDataToLocal();

            // --- UPDATED Status Message ---
            let warnings = [];
            if (missingMandatoryFields > 0) warnings.push(`${missingMandatoryFields} rows were skipped due to missing mandatory data (date, species, number, scene, severity, or likelihood).`);
            if (!hasLocationHeader) warnings.push(`'location' header missing. Map will not be generated.`);
            else if (invalidLocations > 0) warnings.push(`${invalidLocations} rows had invalid 'location' coordinates format (expected "lat, lon") and were not mapped.`);
            else if (rowsWithValidLocation === 0 && processedData.length > 0) warnings.push(`No valid 'location' data found in rows. Map will not be generated.`);

            if (invalidSeverity > 0) warnings.push(`${invalidSeverity} rows had invalid 'severity' values (defaulted to 'Very Low').`);
            if (invalidLikelihood > 0) warnings.push(`${invalidLikelihood} rows had invalid 'likelihood' values (defaulted to 'Very Low').`);

            let statusMsg = `Successfully processed ${processedData.length} valid records. Generating internal analysis...`;
            if (warnings.length > 0) {
                 statusMsg += ` <br><strong>Notes/Warnings:</strong><br>• ${warnings.join('<br>• ')}`;
            }

            showStatusMessage('csv-status', statusMsg, 'demo');
            // Make it clear which airport this data belongs to
            const airportIndicator = document.createElement('p');
            airportIndicator.style.fontSize = '0.9rem';
            airportIndicator.style.color = 'var(--primary-blue)';
            airportIndicator.style.fontWeight = '600';
            airportIndicator.style.marginTop = '0.5rem';
            airportIndicator.innerHTML = `📍 This data is saved for: ${currentAirport.name} (${currentAirport.icao})`;
            document.getElementById('csv-status').appendChild(airportIndicator);

            // Pass the flag indicating if map data is available
            await generateInternalRiskMatrix(processedData, rowsWithValidLocation > 0);
            document.getElementById('csv-upload').value = ''; // Clear file input
        },
        error: (err) => {
            showStatusMessage('csv-status', `Error parsing file: ${err.message}`, 'error');
        }
    });
}

// --- UPDATED generateInternalRiskMatrix ---
async function generateInternalRiskMatrix(data, canDisplayMap) { // Added canDisplayMap flag
    const matrixContainer = document.getElementById('internal-matrix-container');
    const mapContainer = document.getElementById('internal-map-container');
    const trendsContainer = document.getElementById('internal-trends-container');

    // Clear previous outputs first
    if (matrixContainer) matrixContainer.innerHTML = '';
    if (mapContainer) {
         mapContainer.innerHTML = '';
         mapContainer.style.display = 'none';
    }
    if (internalTrendsChart) {
         internalTrendsChart.destroy();
         internalTrendsChart = null;
    }
    if (trendsContainer) trendsContainer.style.display = 'none';
    if (internalMap) {
         internalMap.remove();
         internalMap = null;
    }


    if (!data || data.length === 0) {
        matrixContainer.innerHTML = '<h3>Internal Confirmed Risk Matrix</h3><p>No valid data rows found in the uploaded file.</p>';
        // Ensure map and trends are hidden if data is empty
        if (mapContainer) mapContainer.style.display = 'none';
        if (trendsContainer) trendsContainer.style.display = 'none';
        return;
    }

    // --- Matrix and Highest Risk Calculation (Same as before) ---
    const matrixDataSets = {}; // Use Sets to avoid duplicates per cell
    SEVERITY_LEVELS.forEach(sev => LIKELIHOOD_LEVELS.forEach(lik => matrixDataSets[`${sev}-${lik}`] = new Set()));
    const highestSpeciesRiskMap = new Map(); // For trend chart

    data.forEach(row => {
        const { species, severity, likelihood } = row;
        // No need to check for !species, handled in handleCSVUpload

        matrixDataSets[`${severity}-${likelihood}`]?.add(species);

        const currentRisk = highestSpeciesRiskMap.get(species);
        const newRisk = { severity, likelihood };
        if (!currentRisk || isRiskHigher(newRisk, currentRisk)) {
             highestSpeciesRiskMap.set(species, newRisk);
        }
    });

    // Convert matrix Sets to Arrays for display
    const finalMatrixData = {};
    Object.keys(matrixDataSets).forEach(key => {
        finalMatrixData[key] = Array.from(matrixDataSets[key]).map(name => ({ name, source: 'Internal Data' }));
    });

    // Convert highest risk map to array for trend chart
    currentInternalSpeciesData = Array.from(highestSpeciesRiskMap.entries()).map(([name, risk]) => ({
        name,
        severity: risk.severity,
        likelihood: risk.likelihood,
        source: 'Internal Data (Highest Recorded)' // Clarify source for trends
    }));
    // --- End Calculation ---

    // 1. Display the matrix (Always display if data exists)
    displayInternalRiskMatrix(finalMatrixData);

    // 2. Display the map CONDITIONALLY
    if (canDisplayMap) {
        displayInternalSightingsMap(data);
    } else {
         // Ensure map container is hidden if we can't display it
         if (mapContainer) {
             mapContainer.innerHTML = ''; // Clear just in case
             mapContainer.style.display = 'none';
         }
         if (internalMap) { // Clean up map object if it exists
             internalMap.remove();
             internalMap = null;
         }
         console.log("Skipping internal map generation due to lack of valid location data.");
    }

    // 3. Display the trends (Always display if data exists)
    displayInternalTrendsChart(data, currentInternalSpeciesData);

    // Status message is handled in handleCSVUpload
}

function displayInternalRiskMatrix(data) {
    // This is a copy of displayRiskMatrix, but modified for the internal matrix
    const mc = document.getElementById('internal-matrix-container');
    if (!mc) return;

    // No override controls for this matrix
    const descriptionHTML = `
        <h3>Internal Confirmed Risk Matrix</h3>
        <p style="font-size: 0.9rem; color: var(--text-light); border-left: 3px solid var(--primary-blue); padding-left: 1rem;">
            This matrix is generated **only** from your uploaded internal data.
            Both <strong>Severity</strong> and <strong>Likelihood</strong> are read directly from the corresponding columns in your uploaded CSV file.
            <br>A species may appear in multiple cells if it has been recorded with different risk levels in your data.
        </p>
    `;

    const reversedLikelihood = LIKELIHOOD_LEVELS.slice().reverse();
    let matrixHTML = `${descriptionHTML}<div class="risk-matrix-wrapper"><div class="risk-matrix-y-axis">${SEVERITY_LEVELS.slice().reverse().map(sev =>` <div>${sev}<br>Severity</div>`).join('')}</div><div class="risk-matrix">${reversedLikelihood.map(lik =>` <div class="matrix-header">${lik}<br>Likelihood</div>`).join('')}`;

    SEVERITY_LEVELS.slice().reverse().forEach((sev) => {
        reversedLikelihood.forEach((lik) => {
            const speciesInCell = data[`${sev}-${lik}`] || [];
            const cellClass = getRiskCategory(sev, lik);
            matrixHTML += `<div class="matrix-cell ${cellClass}"><div class="matrix-cell-content">${speciesInCell.map(s => {
                // No manual override styling needed here
                return `<div class="matrix-cell-item" title="Source: ${s.source}">${s.name}</div>`;
            }).join('')}</div></div>`;
        });
    });

    matrixHTML += '</div></div>';
    mc.innerHTML = matrixHTML; // <-- THIS LINE IS NOW CORRECT
    // No event listeners needed as overrides are disabled
    displayNextSteps(); // NEW: Call the function to show guidance
}
// --- NEW FUNCTION TO DISPLAY NEXT STEPS ---
function displayNextSteps() {
    const container = document.getElementById('next-steps-guidance');
    if (!container) return;

    // Make the container visible
    container.style.display = 'block';

    // Define the steps content
    const stepsHTML = `
        <div class="next-steps-container">
            <h4>Next Steps & Recommended Actions</h4>
            <div class="next-steps-grid">
                <div class="next-step-card primary-step">
                    <h4>Step 1: Focus on Intolerable Risks 🚨</h4>
                    <p><strong>Immediately address species in the Red (Intolerable) zone of your Internal Matrix.</strong> These represent confirmed high risks. Review their severity and likelihood. Plan and log mitigation actions in the 'Mitigation Strategy' tab.</p>
                </div>
                <div class="next-step-card">
                    <h4>Step 2: Compare Matrices 📊</h4>
                    <p>Compare your Internal Matrix (confirmed data) with the ICAO Matrix (external pressure). Are there high-risk species in the external data that haven't caused strikes yet? Consider proactive mitigation for these.</p>
                </div>
                <div class="next-step-card">
                    <h4>Step 3: Analyze Trends & Mitigate 📈</h4>
                    <p>Use the 'Trend Analysis' tab to see external pressure patterns. Correlate spikes with internal logs and mitigation effectiveness (logged in the 'Mitigation' tab). Refine your Wildlife Hazard Management Programme (WHMP).</p>
                </div>
                 <div class="next-step-card">
                    <h4>Step 4: Refine & Report ✍️</h4>
                    <p>Continuously update your internal data via CSV uploads or the IBIS form. Use the generated insights for safety meetings, WHMP reviews, and regulatory reporting.</p>
                </div>
            </div>
        </div>
    `;

    container.innerHTML = stepsHTML;
}
// --- NEW FUNCTION FOR INTERNAL DATA TREND CHART ---
function displayInternalTrendsChart(data, internalSpeciesRiskData) {
    const container = document.getElementById('internal-trends-container');
    const ctx = document.getElementById('internal-trends-chart')?.getContext('2d');

    if (!container || !ctx || !data || data.length === 0) {
        if(container) container.style.display = 'none'; // Hide if no data
        return;
    }

    // Destroy previous chart instance
    if (internalTrendsChart) {
        internalTrendsChart.destroy();
    }

    // --- Process data for the chart - SIMPLIFIED LOGIC ---
const dailyData = {}; // Structure: { 'YYYY-MM-DD': { intolerable: { count: N, species: Set() }, tolerable: {count: N, species: Set()}, acceptable: {count: N, species: Set()} } }
let minDate = null, maxDate = null;

data.forEach(row => {
    // Validate essential row data
    if (!row.date || !row.species || !row.severity || !row.likelihood) {
        console.warn("Skipping row with missing essential data:", row);
        return;
    }

    // --- Date Parsing (Use UTC) ---
    const parts = row.date.split('-');
    let dateObj;
    if (parts.length === 3 && parts[0].length === 4) {
        // This handles 'YYYY-MM-DD'
        dateObj = new Date(Date.UTC(parts[0], parts[1] - 1, parts[2]));
    } else {
         // This handles 'MM/DD/YYYY' (or other formats) by using the local parser
         dateObj = new Date(row.date);
         // Then it converts the local date components to a UTC date object
         if (!isNaN(dateObj.getTime())) {
             dateObj = new Date(Date.UTC(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate()));
         }
    }
    if (isNaN(dateObj.getTime())) {
         console.warn("Skipping row with invalid date format:", row);
         return; // Skip rows with invalid date format
    }
    const year = dateObj.getUTCFullYear();
    const month = String(dateObj.getUTCMonth() + 1).padStart(2, '0');
    const day = String(dateObj.getUTCDate()).padStart(2, '0');
    const date = `${year}-${month}-${day}`; // Consistent UTC YYYY-MM-DD key
    // --- End Date Parsing ---

    // Track min/max dates
    if (minDate === null || date < minDate) minDate = date;
    if (maxDate === null || date > maxDate) maxDate = date;

    // Initialize day in dailyData if needed
    if (!dailyData[date]) {
        dailyData[date] = {
            // *** CHANGE: Use Map instead of Set to store species counts ***
            intolerable: { count: 0, species: new Map() },
            tolerable: { count: 0, species: new Map() },
            acceptable: { count: 0, species: new Map() }
        };
    }

    const speciesName = row.species;
    const numberSeen = row.number; // Already parsed and defaulted in handleCSVUpload

    // 1. Determine the category based on THIS ROW'S actual risk.
    const actualRiskCategory = getRiskCategory(row.severity, row.likelihood);

    // 2. Add BOTH the total count and the individual species count to the SAME category bucket.
    if (dailyData[date][actualRiskCategory]) {
        dailyData[date][actualRiskCategory].count += numberSeen; // Increment total count for the category

        // *** CHANGE: Update species Map with its count ***
        const speciesMap = dailyData[date][actualRiskCategory].species;
        speciesMap.set(speciesName, (speciesMap.get(speciesName) || 0) + numberSeen); // Add numberSeen to existing count or start from numberSeen

    } else {
        // Fallback for 'unknown' or other invalid categories (defaults to 'acceptable')
        dailyData[date].acceptable.count += numberSeen;

        // *** CHANGE: Update fallback species Map ***
        const speciesMap = dailyData[date].acceptable.species;
        speciesMap.set(speciesName, (speciesMap.get(speciesName) || 0) + numberSeen);
    }
}); // End data.forEach

    if (!minDate || !maxDate) {
        container.style.display = 'none'; // Hide if no valid dates found
        return;
    }

    // --- Generate labels for the full date range ---
    const dateLabels = [];
    let currentDate = new Date(minDate + 'T00:00:00Z'); // Start at UTC midnight
    const endDate = new Date(maxDate + 'T00:00:00Z'); // End at UTC midnight

    while (currentDate <= endDate) {
        const year = currentDate.getUTCFullYear();
        const month = String(currentDate.getUTCMonth() + 1).padStart(2, '0');
        const day = String(currentDate.getUTCDate()).padStart(2, '0');
        dateLabels.push(`${year}-${month}-${day}`);
        currentDate.setUTCDate(currentDate.getUTCDate() + 1); // Increment day in UTC
    }

    // --- Prepare Chart.js datasets (Same as before) ---
    const rootStyles = getComputedStyle(document.documentElement);
    const intolerableColor = rootStyles.getPropertyValue('--risk-intolerable').trim();
    const tolerableColor = rootStyles.getPropertyValue('--risk-tolerable').trim();
    const acceptableColor = rootStyles.getPropertyValue('--risk-acceptable').trim();
    const intolerableDataset = { label: 'Intolerable Sightings', data: dateLabels.map(label => ({ x: label, y: dailyData[label]?.intolerable.count || 0 })), borderColor: intolerableColor, backgroundColor: intolerableColor + '80', tension: 0.1, fill: false, borderWidth: 2.5 };
    const tolerableDataset = { label: 'Tolerable Sightings', data: dateLabels.map(label => ({ x: label, y: dailyData[label]?.tolerable.count || 0 })), borderColor: tolerableColor, backgroundColor: tolerableColor + '80', tension: 0.1, fill: false, borderWidth: 2.5 };
    const acceptableDataset = { label: 'Acceptable Sightings', data: dateLabels.map(label => ({ x: label, y: dailyData[label]?.acceptable.count || 0 })), borderColor: acceptableColor, backgroundColor: acceptableColor + '80', tension: 0.1, fill: false, borderWidth: 2.5 };

    // --- Create the chart ---
    container.style.display = 'block'; // Make the container visible

    internalTrendsChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [intolerableDataset, tolerableDataset, acceptableDataset]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day', tooltipFormat: 'yyyy-MM-dd' },
                    title: { display: true, text: 'Date' }
                },
                y: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Number Seen' }, beginAtZero: true },
            },
            plugins: {
                tooltip: {
                    bodyAlign: 'left',
                    callbacks: {
                        // --- ENHANCED TOOLTIP FOOTER LOGIC (with counts) ---
                    footer: function(tooltipItems) {
                        if (!tooltipItems || tooltipItems.length === 0) { return null; }
                        const item = tooltipItems[0];
                        const dateTimestamp = item.parsed.x;
                        const d = new Date(dateTimestamp);

                        // --- Generate the lookup key using LOCAL date parts ---
                        const year = d.getFullYear();
                        const month = String(d.getMonth() + 1).padStart(2, '0');
                        const day = String(d.getDate()).padStart(2, '0');
                        const dateString = `${year}-${month}-${day}`;
                        // --- END LOCAL DATE KEY ---

                        const dataForDay = dailyData[dateString];
                        if (!dataForDay) {
                            console.warn(`Tooltip: No dailyData found for derived local date: ${dateString}`);
                            return null;
                        }

                        const datasetIndex = item.datasetIndex;
                        let speciesMap; // *** CHANGE: Variable name from speciesSet to speciesMap ***
                        let title = '';
                        let categoryKey = '';

                        if (datasetIndex === 0) {
                            categoryKey = 'intolerable'; title = 'Intolerable Species Seen:';
                        } else if (datasetIndex === 1) {
                            categoryKey = 'tolerable'; title = 'Tolerable Species Seen:';
                        } else {
                            categoryKey = 'acceptable'; title = 'Acceptable Species Seen:';
                        }

                        // *** CHANGE: Access the Map instead of Set ***
                        speciesMap = dataForDay[categoryKey]?.species;

                        const plottedCount = item.parsed.y;

                        // *** CHANGE: Check Map size instead of Set size ***
                        if (plottedCount === 0 || !speciesMap || speciesMap.size === 0) {
                            return null;
                        }

                        // *** CHANGE: Convert Map entries to array [name, count] and sort by name ***
                        const speciesArray = Array.from(speciesMap.entries()).sort((a, b) => a[0].localeCompare(b[0]));
                        let footerLines;

                        // Apply wrapping logic for long lists
                        if (speciesArray.length > 10) {
                            const wrappedLines = [];
                            let currentLine = '';
                            // *** CHANGE: Loop through [species, count] pairs ***
                            speciesArray.forEach(([species, count]) => {
                                const speciesString = `${species} (${count})`; // Format name with count

                                if (currentLine === '') {
                                    currentLine = speciesString;
                                } else if (currentLine.length + speciesString.length + 2 < 70) { // Check length with count included
                                    currentLine += `, ${speciesString}`;
                                } else {
                                    wrappedLines.push(currentLine);
                                    currentLine = speciesString;
                                }
                            });
                            wrappedLines.push(currentLine);
                            footerLines = wrappedLines;
                        } else {
                            // Use vertical list for shorter lists
                            // *** CHANGE: Map [species, count] pairs to formatted string ***
                            footerLines = speciesArray.map(([name, count]) => `- ${name} (${count})`);
                        }

                        footerLines.unshift(title);
                        return footerLines;
                    }
                    // --- END ENHANCED TOOLTIP FOOTER LOGIC ---
                    }
                }
            }
        }
    });
}
});
</script>
</body>
</html>